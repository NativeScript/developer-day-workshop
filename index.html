<!DOCTYPE html> 
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>NativeScript Developer Day Workshop</title>

	<meta charset="utf-8">
	<meta name="description" content="A guide to help hybrid mobile developers migrate to building native mobile apps with NativeScript">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="container">
	<div id="header">
		<a href="#" class="menu header-btn" id="toggle-toc"></a>
		<h1>NativeScript Developer Day Workshop</h1>
		<a href="https://github.com/nativescript/developer-day-workshop" class="github header-btn"></a>
	</div>

	<div id="content-container">
		<div id="toc">
			<div class="toc-heading">Table of Contents</div>
			<div id="toc-padding"></div>
		</div>
		<div id="book">
			<div class="chapter">
				<h2 id="introductions">Introductions</h2>
<p>Welcome! The following is your home for the <a href="http://developerday.nativescript.org/">NativeScript Developer Day</a> workshop, being held on September 19th, 2016, in Boston, Massachusetts. Below you’ll find all slides and instructions for the hands-on activities being held throughout the day. The site will remain up well after the event so you can refer back to the material at any time.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>All attendees must have the NativeScript CLI installed, and all system requirements in place to develop for <em>either</em> iOS or Android. If you haven’t already, complete the installation instructions using the link below.</p>
<ul>
<li><a href="http://docs.nativescript.org/angular/start/quick-setup.html">Complete the NativeScript installation guide</a></li>
</ul>
<blockquote>
<p><strong>TIP</strong>: If you run into issues completing the setup instructions, try <a href="http://developer.telerik.com/wp-login.php?action=slack-invitation">joining the NativeScript Slack</a> and asking questions in the #getting-started channel.</p>
</blockquote>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="what-is-nativescript-">What is NativeScript?</h2>
<p>We’ll start the day with a brief introduction to what NativeScript is, and why you might want to use NativeScript to build your next mobile app. Because we know you’re not here to see us talk in front of slides all day, we’ll keep this short and to the point.</p>
<ul>
<li><a href="/slides/NativeScript-Developer-Day-Slides.pptx">Download slides (.pptx)</a></li>
<li><a href="/slides/NativeScript-Developer-Day-Slides.pdf">Download slides (.pdf)</a></li>
</ul>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="the-basics">The basics</h2>
<p>For our first hands-on workshop, you’ll learn how to build and manage NativeScript apps, as well as how to make simple changes and debug your code.</p>
<h3 id="how-the-cli-works">How the CLI works</h3>
<p>The CLI allows you to perform various tasks from creating a new project, to building an app, to importing plugins, and a whole lot more. All the CLI commands start with a prefix <code>tns</code>.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create your first project
</h4>

<p>Open your terminal (Mac) or command-line console (Windows) and navigate to the folder where you want to create your first project. Now run the following command:</p>
<pre><code>tns create WorkshopOne --ng
</code></pre><p><code>WorkshopOne</code> is the name of the project, while <code>--ng</code> tells the CLI to create an ng2 type of project.</p>
<p>When complete, navigate into the created project folder:</p>
<pre><code>cd WorkshopOne
</code></pre><div class="exercise-end"></div>


<p>At this point we have a hello world type of project, with a bit of simple logic.
Now we need to add the platforms for which we want to build this app.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Adding mobile platforms
</h4>

<p>To add Android to your project run:</p>
<pre><code>tns platform add android
</code></pre><p>If you’re on a Mac, add iOS with</p>
<pre><code>tns platform add ios
</code></pre><div class="exercise-end"></div>


<p>Now we will learn how to build and run your apps.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Running the app
</h4>

<p>To build an Android app, and run it on a connected device or Genymotion instance, call: </p>
<pre><code>tns run android
</code></pre><p>However, if you want to run the app in an emulator you should call</p>
<pre><code>tns run android --emulator
</code></pre><p>The same applies to building and running iOS apps—just swap <code>android</code> for <code>ios</code></p>
<pre><code>tns run ios --emulator
</code></pre><blockquote>
<p>Note: If you want to stop the build process just press <code>CTRL+C</code>.</p>
</blockquote>
<div class="exercise-end"></div>


<p>Sometimes waiting for the build process can take some time, especially when you need to rebuild the app every time you make a tiny change to the code.</p>
<p>This is why the CLI has the <code>livesync</code> command, which allows you to build the app in a way that whenever you make a change in your code the app will get refreshed really quickly.</p>
<p>To make it more insteresting, if you make a change to your TypeScript code, the CLI will transpile it to JavaScript first, and then refresh the app.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Livesync
</h4>

<p>Build your app using the <code>livesync</code> command and then open your <code>app.css</code> file, such as adding <code>color: red</code> to the <code>.title</code> selector, and save the file.</p>
<blockquote>
<p>Note: You’ll need to stop the previous <code>run</code> command with <code>CTRL+C</code>.</p>
</blockquote>
<pre><code>tns livesync android --watch
</code></pre><p>or </p>
<pre><code>tns livesync ios --emulator --watch
</code></pre><div class="exercise-end"></div>

<!--
<h4 class="exercise-start">
    <b>Exercise</b>: Debugging
</h4>

Build your app in debug mode using the following command.
This should launch debugging tools for you. Once that is ready find app.component.js add a breakpoint to `onTap()` then tap on the button and try to explore what you can do with it.

```
tns debug android
```

or
```
tns debug ios --emulator
```

You probably noticed that when you debug your app, the debugging tools operate on JavaScript, not TypeScript. This is because NativeScript runs on JavaScript code, which is transpiled from TypeScript.

Here is an interesting thing. Launching a debugger is a very slow process, but yet again `livesync` comes in to save the day.
You can run the debugger in the livesync mode by adding `--watch` at the end of the command, like this:

```
tns debug android --watch
```

or

```
tns debug ios --watch --emulator
```

<div class="exercise-end"></div>
-->
<h3 id="nativescript-folder-structure">NativeScript folder structure</h3>
<p>At the root of the project we have <code>package.json</code>, which contains all npm dependencies and project configuration.
This is where you can change the id of the project or the app version.</p>
<p>On top of that NativeScript project is made of a number of folders, however you should mainly pay attention to 3 of them.</p>
<p><strong> the <code>app</code> folder</strong> 
This is where the code of the application goes.</p>
<p>Some of the most notable files here are:</p>
<ul>
<li><code>main.ts</code> - is where the application starts. It is also the file where you can initialize the routing configuration for page navigation.</li>
<li><code>app.css</code> - is the global css file, the styling contained here is applied accross the whole of the application</li>
<li><code>app.component.ts</code> - by default it contains the first angular component that gets loaded when you run the app, however most apps that you will work on will probably use a different component as the starting one.  </li>
<li><code>App_Resources</code> - this folder contains platform-specific files, such as icons, splash screens, and Android and iOS configuration files.</li>
</ul>
<p><strong>the <code>node_modules</code> folder</strong></p>
<p>This folder contains all npm modules specified in the <code>package.json</code>.</p>
<p>This folder can be easily regenerated, this means that you can safely delete it whenever you feel like.</p>
<p>You should also refrain from pushing the folder into git or any source control.</p>
<p><strong>the <code>platforms</code> folder</strong></p>
<p>This is the build folder for each of your platforms.</p>
<p>Just like the <code>node_modules</code> folder, this folder can be regenerated at will, so you should never add it to your source control.</p>
<h3 id="working-in-visual-studio-code">Working in Visual Studio Code</h3>
<p>There are a number of IDEs that you might be used to work with, however for the purpose of this workshop we will focus on working with VS Code, which has a lot of really good features that can help you build NativeScript apps.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Setting up the IDE
</h4>

<p>Download Visual Studio Code <a href="https://code.visualstudio.com/download">from its official download page</a> and install it.</p>
<p>Now we will add NativeScript extensions to Visual Studio Code.
Just run VS Code and go to the Extensions tab (on Cac press <code>shift</code> + <code>command</code> + <code>x</code> on windows press <code>shift</code> + <code>ctrl</code> + <code>x</code>). 
From here search for &#39;nativescript&#39;, once the search returns reults install <code>NativeScript</code> and <code>NativeScript + Angular 2 Snippets</code>.</p>
<p><img src="https://github.com/NativeScript/developer-day-workshop/blob/gh-pages/images/vscode-nsext-install.png?raw=true" alt="Search result and install"></p>
<p>Installing each them shouldn&#39;t take too long, once ready you will be prompted to enable the extensions, just click on “enable” next to one of the modules, which will restart VS Code and you will be ready to go.</p>
<p><img src="https://github.com/NativeScript/developer-day-workshop/blob/gh-pages/images/vscode-nsext-enable.png?raw=true" alt="Search result and install"></p>
<div class="exercise-end"></div>

<p>Now that VS Code is ready, let&#39;s see how it can be of service.
We will start by playing with code snippets.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Using code snippets
</h4>

<p>First open the <code>WorkshopOne</code> project folder in VS Code by using <code>File</code> -&gt; <code>Open</code>.
Then find <code>app\app.component.html</code> (this file contains the UI definition of app.component).</p>
<p>Add a new line just before the closing <code>&lt;/StackLayout&gt;</code> tag and start typing <code>ns</code> immediately you will get a list of available snippets. If you keep typing the list of available snippets will narrow down.</p>
<p>When you select one of the snippets and hit <code>enter</code> the text you were typing will be replaced with a snippet. Some snippets will have more than one place where you can type, you can <code>tab</code> through them.</p>
<p>For this exercise add the following components using code snippets.</p>
<ul>
<li>Label with the <code>text</code> set to <code>Email:</code> -&gt; <code>nslabel</code></li>
<li>TextField with the <code>hint</code> set to <code>email...</code> -&gt; <code>nstextfield</code></li>
<li>Label with the <code>text</code> set to <code>Passowrd</code> -&gt; <code>nslabel</code></li>
<li>TextField with the <code>hint</code> set to <code>password...</code> -&gt; <code>nstextfield</code></li>
<li>Button with the <code>text</code> set <code>Sign In</code> and <code>tap</code> set to <code>signIn()</code> -&gt; <code>nsbtn</code></li>
</ul>
<p><img src="https://github.com/NativeScript/developer-day-workshop/blob/gh-pages/images/vscode-using-snippets.gif?raw=true" alt="Creating login screen"></p>
<p>Try to add the snippets on your own, but if you need help show the solution below.</p>
<div class="solution-start"></div>

<pre><code class="lang-XML">&lt;Label [text]=&quot;message&quot; class=&quot;message&quot; textWrap=&quot;true&quot;&gt;&lt;/Label&gt;
&lt;Label text=&quot;Email:&quot; textWrap=&quot;true&quot;&gt;&lt;/Label&gt;
&lt;TextField hint=&quot;email...&quot; text=&quot;&quot;&gt;&lt;/TextField&gt;
&lt;Label text=&quot;Password:&quot; textWrap=&quot;true&quot;&gt;&lt;/Label&gt;
&lt;TextField hint=&quot;password...&quot; text=&quot;&quot;&gt;&lt;/TextField&gt;
&lt;Button text=&quot;Sign In&quot; (tap)=&quot;signIn()&quot;&gt;&lt;/Button&gt;
</code></pre>
<div class="solution-end"></div>

<p>Now open <code>app.component.ts</code> and add the following function to the <code>AppComponent</code> class:</p>
<pre><code class="lang-TypeScript">public signIn() {
    alert(&quot;NativeScript is great&quot;);
}
</code></pre>
<p>When done, run the app and see what you got.</p>
<div class="exercise-end"></div>

<!--

You can also create your own snippets.

<h4 class="exercise-start">
    <b>Bonus Exercise</b>: Create your own snippet 
</h4>

Open the `User Snippets` editor and select `TypeScript`.

On a Mac: `Code->Preferences->User Snippets`

![User Snippets on Mac](https://github.com/NativeScript/developer-day-workshop/blob/gh-pages/images/vscode-snippets-mac.png?raw=true) 

On Windows: `File->Preferences->User Snippets`

![User Snippets on](https://github.com/NativeScript/developer-day-workshop/blob/gh-pages/images/vscode-snippets-win.png?raw=true) 

Now add the following snippet
``` TypeScript
"shorthand for console.log": {
    "prefix": "tsprint",
    "body": [
        "console.log('${text}')",
        "$2"
    ]
}
```

This snippet will serve us as a shorthand for `console.log`, you can trigger it by expanding `tsprint` in your TypeScript code.

In `app.component.ts` go to `onTap` function and start typing `tsp` and press `Enter`.
Straight away the cursor will be placed on top of the `text` placeholder. Change it to `hello` and press `tab` which will take you to the new line (`$2`);

You can learn more about VS Code snippets [here](https://code.visualstudio.com/docs/customization/userdefinedsnippets)

<div class="exercise-end"></div>


VS Code can be really helpful with code prediction when you try to work your TypeScript magic.
The Intellisense not only knows about the attributes and functions of your current class, but it can also help you with code predition for any TypeScript based module you use.


You can enhance your Intellisense experience by adding comments to your functions
<h4 class="exercise-start">
    <b>Bonus Exercise</b>: Add Intellisense friendly comments
</h4>

Add the following function at the bottom of `app.componenents.ts` (outside the `AppComponent` class).
``` TypeScript
/**
 * Prints the provided text in uppercase
 * @param text text to be printed 
 */
function largePrint(text: string) {
    console.log(text.toUpperCase());
}
```

Now you can use the `largePrint` function, which will provide you with the description of the function and its parameter. 

<div class="exercise-end"></div>
-->
<p>VS Code also provides support for debugging NativeScript code, and to make it even more interesting, the extension also lets you debug directly in TypeScript. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Debugging in VS Code
</h4>

<p>Open the debug tab - click the debug icon on the left-hand side: <img src="https://github.com/NativeScript/developer-day-workshop/blob/gh-pages/images/vscode-icon-debug.png?raw=true" alt="Debug View icon"></p>
<p>From here press the little gear icon to <code>Select the build environment</code> and choose <code>NativeScript</code>
<img src="https://github.com/NativeScript/developer-day-workshop/blob/gh-pages/images/vscode-icon-gear.png?raw=true" alt="Select the build environment icon"></p>
<p>When the IDE is ready, click on the drop down next to the gear icon and select:
<code>Attach on Android</code> or <code>Attach on iOS</code> and press the green play button.</p>
<p>This might take a minute or two, especially when you run it for the first time.</p>
<blockquote>
<p><strong>NOTE</strong>: If the debugger detaches after the app started, re-select <code>Attach on iOS</code> and press play. This should fix the problem.</p>
</blockquote>
<p>As part of this exercise open <code>app.component.ts</code> and add a breakpoint to the <code>onTap</code> function by clicking to the left of the line number where you’d like to add the breakpoint. And then tap on the tap button in your app.
The debugger should stop at your breakpoint.</p>
<p>Here is how I did it:
<img src="https://github.com/NativeScript/developer-day-workshop/blob/gh-pages/images/vscode-configure-debugger.gif?raw=true" alt="Using the debugger in VS Code"></p>
<p>When you are in debug mode you can:</p>
<ul>
<li>hover over variables to check their value or add them to the watch list</li>
<li>step in or step over the code</li>
<li><p>use the <code>Debug Console</code> on the bottom of the screen to run commands or read/edit variables.</p>
<p>Try to change the value of the <code>counter</code> by running the following command in the <code>Debug Console</code>.</p>
<pre><code class="lang-TypeScript">this.counter = 100;
</code></pre>
</li>
</ul>
<div class="exercise-end"></div>


			</div>
			<hr>
			<div class="chapter">
				<h2 id="the-user-interface">The user interface</h2>
<p>Now that you’ve gotten a feel for how NativeScript apps work, let’s shift our focus to the user interface. In our second hands-on workshop, you’ll learn about using UI components, styling them with CSS, and animating them with NativeScript’s robust animation library. In this workshop, we&#39;ll create an adorable Kitten Adoption app with a card interface.</p>
<h3 id="adding-ui-components">Adding UI components</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Create a new app
</h4>

<p>Let&#39;s create a new NativeScript app for this workshop:</p>
<pre><code>tns create WorkshopTwo --ng
</code></pre><p>Next, change directories into your new project:</p>
<pre><code>cd WorkshopTwo
</code></pre><div class="exercise-end"></div>

<p>Open this new project up in Visual Studio Code (you can type <code>code .</code>).</p>
<p>First, let&#39;s take a look at the files we will need to work with. Notice in the <code>/app</code> folder of your project there is a file called <code>app.component.ts</code>. This is where you put the functions that are called by the front-end file, <code>app.component.html</code>.</p>
<p>Open <code>app.component.html</code> and delete everything there.</p>
<p>Start your app&#39;s livesyncing process on iOS by typing into the command line:</p>
<pre><code>tns livesync ios --watch
</code></pre><p>For Android, we recommend using Genymotion; open Genymotion and start livesync by typing</p>
<pre><code>tns livesync android --watch
</code></pre><p>Now, when you make changes to your code, your app will refresh in the emulator.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add your first UI element
</h4>

<p>Native apps need native-looking controls. We will create a native ActionBar using XML markup. In <code>app.component.html</code>, put this line at the top:</p>
<pre><code class="lang-XML">&lt;ActionBar title=&quot;Adopt A Kitten!&quot;&gt;&lt;/ActionBar&gt;
</code></pre>
<div class="exercise-end"></div>

<p>Before we go further, we need some data that we can layout on the screen. Let&#39;s grab ten kitten images from <a href="http://placekitten.com">placekitten.com</a> to have them ready to place on our app screen.</p>
<blockquote>
    <p><strong>Note</strong>: If your iOS app complains about not being able to load insecure content, follow the instructions <a href="https://www.thepolyglotdeveloper.com/2015/12/fix-ios-9-app-transport-security-issues-in-nativescript/">here</a> and rebuild your app by running <code>tns run ios</code>.</p>
</blockquote>

<h4 class="exercise-start">
    <b>Exercise</b>: Get some data ready
</h4>

<p>We won&#39;t go into the details now of binding your data to UI as you&#39;ll cover this in the next workshop.</p>
<p>Open <code>app.component.ts</code> and delete everything there. Replace it with the code below:</p>
<pre><code class="lang-TypeScript">import {Component} from &quot;@angular/core&quot;;

@Component({
    selector: &quot;my-app&quot;,
    templateUrl: &quot;app.component.html&quot;
})
export class AppComponent {
    public kittens: Array&lt;any&gt;;
    public url: string;
    public counter:number = 200;

    constructor() {
        this.kittens = [];
        this.url = &#39;https://placekitten.com/200/&#39;;

        for (var i = 0; i &lt; 10; i++) {
            this.counter++;
            this.kittens.push(this.url+this.counter);
        }
    }
}
</code></pre>
<p>We&#39;ll use this data in our layout in the next section.</p>
<div class="exercise-end"></div>

<h3 id="types-of-layouts">Types of layouts</h3>
<p>There are five basic layouts offered by NativeScript that correspond to standard native ways of laying elements out onto a page: StackLayout, GridLayout, WrapLayout, DockLayout, and AbsoluteLayout. Let&#39;s take a look at these, and, as a bonus, a ListView.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Experiment with layouts
</h4>

<p>One of the simplest layouts is a StackLayout, which simply stacks elements on top of each other. Paste this code under the ActionBar: </p>
<pre><code class="lang-XML">&lt;StackLayout horizontalAlignment=&quot;center&quot;&gt;
    &lt;Image [src]=&quot;kittens[0]&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image [src]=&quot;kittens[1]&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image [src]=&quot;kittens[2]&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
&lt;/StackLayout&gt;
</code></pre>
<p>If you want your content to simply wrap, use WrapLayout. Delete the StackLayout and replace it with this snippet:</p>
<pre><code class="lang-XML">&lt;WrapLayout&gt;
    &lt;Image src=&quot;https://placekitten.com/100/100&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/100/100&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/100/100&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/100/100&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/100/100&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/100/100&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/100/100&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/100/100&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/100/100&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/100/100&quot; stretch=&quot;none&quot;&gt;&lt;/Image&gt;
&lt;/WrapLayout&gt;
</code></pre>
<p>If you need to position your element in an exact spot, use AbsoluteLayout. Delete the WrapLayout and replace it with the following snippet:</p>
<pre><code class="lang-XML">&lt;AbsoluteLayout&gt;
     &lt;Image [src]=&quot;kittens[0]&quot; left=&quot;100&quot; top=&quot;100&quot; width=&quot;200&quot; height=&quot;200&quot; &gt;&lt;/Image&gt;
&lt;/AbsoluteLayout&gt;
</code></pre>
<p>Delete the AbsoluteLayout, and try a grid layout by replacing the AbsoluteLayout with the snippet below. You can have control over the format of your grid by tweaking the &#39;*&#39; values. Note the columns/rows vs col/row values.</p>
<pre><code class="lang-XML">&lt;GridLayout columns=&quot;*,*,*&quot; rows=&quot;*,*,*,*&quot;&gt;
    &lt;Image [src]=&quot;kittens[0]&quot; col=&quot;0&quot; row=&quot;0&quot; colSpan=&quot;2&quot; rowSpan=&quot;2&quot; stretch=&quot;aspectFill&quot; class=&quot;img&quot;&gt;&lt;/Image&gt;
    &lt;Image [src]=&quot;kittens[1]&quot; col=&quot;2&quot; row=&quot;0&quot; stretch=&quot;aspectFill&quot; class=&quot;img&quot;&gt;&lt;/Image&gt;
    &lt;Image [src]=&quot;kittens[2]&quot; col=&quot;2&quot; row=&quot;1&quot; stretch=&quot;aspectFill&quot; class=&quot;img&quot;&gt;&lt;/Image&gt;
    &lt;Image [src]=&quot;kittens[3]&quot; col=&quot;0&quot; row=&quot;2&quot; stretch=&quot;aspectFill&quot; class=&quot;img&quot;&gt;&lt;/Image&gt;
    &lt;Image [src]=&quot;kittens[4]&quot; col=&quot;1&quot; row=&quot;2&quot; stretch=&quot;aspectFill&quot; class=&quot;img&quot;&gt;&lt;/Image&gt;
    &lt;Image [src]=&quot;kittens[5]&quot; col=&quot;2&quot; row=&quot;2&quot; rowSpan=&quot;2&quot; stretch=&quot;aspectFill&quot; class=&quot;img&quot;&gt;&lt;/Image&gt;
    &lt;Image [src]=&quot;kittens[7]&quot; col=&quot;0&quot; row=&quot;3&quot; colSpan=&quot;2&quot; stretch=&quot;aspectFill&quot; class=&quot;img&quot;&gt;&lt;/Image&gt;
&lt;/GridLayout&gt;
</code></pre>
<p>If you need elements &#39;docked&#39; onto the top, bottom, and/or sides of your app interface, try a DockLayout by overwriting the GridLayout with this snippet:</p>
<pre><code class="lang-XML">&lt;DockLayout&gt;
    &lt;Image dock=&quot;left&quot; width=&quot;80&quot; [src]=&quot;kittens[0]&quot; stretch=&quot;aspectFill&quot;&gt;&lt;/Image&gt;
    &lt;Image dock=&quot;top&quot; height=&quot;80&quot; [src]=&quot;kittens[1]&quot; stretch=&quot;aspectFill&quot;&gt;&lt;/Image&gt;
    &lt;Image dock=&quot;right&quot; width=&quot;80&quot; [src]=&quot;kittens[2]&quot; stretch=&quot;aspectFill&quot;&gt;&lt;/Image&gt;
    &lt;Image dock=&quot;bottom&quot; height=&quot;80&quot; [src]=&quot;kittens[3]&quot; stretch=&quot;aspectFill&quot;&gt;&lt;/Image&gt;
    &lt;Image [src]=&quot;kittens[4]&quot; stretch=&quot;aspectFill&quot;&gt;&lt;/Image&gt;
&lt;/DockLayout&gt;
</code></pre>
<p><b>Bonus!</b> Finally, try a ListView by overwriting the DockLayout snippet with the snippet below. ListViews aren&#39;t a layout per se, but deserve to be tried out. This one has some fancy layouting with left and right alignment:</p>
<pre><code class="lang-XML">&lt;ListView [items]=&quot;kittens&quot;&gt;
    &lt;template let-item=&quot;item&quot; let-odd=&quot;odd&quot; let-even=&quot;even&quot;&gt;
        &lt;DockLayout&gt;
            &lt;Image [src]=&quot;item&quot; width=&quot;50&quot; height=&quot;50&quot; dock=&quot;{{ odd ? &#39;left&#39; : &#39;right&#39; }}&quot;&gt;&lt;/Image&gt;
            &lt;Label text=&quot;minou&quot; textWrap=&quot;true&quot; horizontalAlignment=&quot;{{ odd ? &#39;left&#39; : &#39;right&#39; }}&quot;&gt;&lt;/Label&gt;
        &lt;/DockLayout&gt;
    &lt;/template&gt;
&lt;/ListView&gt;
</code></pre>
<div class="exercise-end"></div>

<p>You can mix and match layouts, and have full control over the way your app looks using proper layouting.</p>
<h3 id="create-a-card-layout">Create a card layout</h3>
<p>Now it&#39;s time to have some fun with creating a little functional layout for our kitten adoption app. We&#39;re going to create a card layout by combining StackLayout and WrapLayout.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Place the kitten images in a scrolling StackLayout
</h4>

<p>What happens if you just put an array of kitten images within a StackLayout?</p>
<p>In <code>app.component.html</code>, replace any code you have under the ActionBar with this snippet: </p>
<pre><code class="lang-XML">&lt;StackLayout&gt;
    &lt;Image src=&quot;https://placekitten.com/300/300&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/300/300&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/300/300&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/300/300&quot;&gt;&lt;/Image&gt;
    &lt;Image src=&quot;https://placekitten.com/300/300&quot;&gt;&lt;/Image&gt;
&lt;/StackLayout&gt;
</code></pre>
<p>The images are stacked, but they don&#39;t scroll.</p>
<p>Nest your StackLayout into a ScrollView:</p>
<pre><code class="lang-XML">&lt;ScrollView&gt;
  &lt;StackLayout&gt;
      &lt;Image src=&quot;https://placekitten.com/300/300&quot;&gt;&lt;/Image&gt;
      &lt;Image src=&quot;https://placekitten.com/300/300&quot;&gt;&lt;/Image&gt;
      &lt;Image src=&quot;https://placekitten.com/300/300&quot;&gt;&lt;/Image&gt;
      &lt;Image src=&quot;https://placekitten.com/300/300&quot;&gt;&lt;/Image&gt;
      &lt;Image src=&quot;https://placekitten.com/300/300&quot;&gt;&lt;/Image&gt;
  &lt;/StackLayout&gt; 
&lt;/ScrollView&gt;
</code></pre>
<div class="exercise-end"></div>

<p>It&#39;s all fine to add images manually to an app, but any data-driven app will need to have data loaded dynamically. Let&#39;s get our StackLayout to loop, so we can start creating cards.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create the kitten cards
</h4>

<p>In <code>app.component.html</code>, replace the current ScrollView with a layout that is generated dynamically:</p>
<pre><code class="lang-XML">&lt;ScrollView&gt;
    &lt;StackLayout *ngFor=&quot;let kitten of kittens&quot;&gt;
       &lt;Image [src]=&quot;kitten&quot;&gt;&lt;/Image&gt;
    &lt;/StackLayout&gt;
&lt;/ScrollView&gt;
</code></pre>
<div class="exercise-end"></div>

<p>Notice the actual images (there should be 10) aren&#39;t laid out in a loop. We need to nest our layout to do this.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Dynamically layout the cards
</h4>

<p>In <code>app.component.html</code>, replace the current ScrollView with a WrapLayout that will allow the StackLayout to loop.</p>
<pre><code class="lang-XML">&lt;ScrollView&gt;
    &lt;WrapLayout&gt;
        &lt;StackLayout *ngFor=&quot;let kitten of kittens&quot;&gt;
           &lt;Image [src]=&quot;kitten&quot;&gt;&lt;/Image&gt;
        &lt;/StackLayout&gt;
    &lt;/WrapLayout&gt;
&lt;/ScrollView&gt;
</code></pre>
<p>This allows the layout to loop, but the cards don&#39;t look very good. Let&#39;s control the width of the cards by making their width a percentage and align them horizontally:</p>
<pre><code class="lang-XML">&lt;StackLayout width=&quot;40%&quot; *ngFor=&quot;let kitten of kittens&quot; horizontalAlignment=&quot;center&quot;&gt;
</code></pre>
<p>Next, align the cards to the center by controlling the alignment of the WrapLayout:</p>
<pre><code class="lang-XML">&lt;WrapLayout horizontalAlignment=&quot;center&quot;&gt;
</code></pre>
<p>Now we have a wrapping layout of cards dynamically loaded onto the screen!</p>
<p>The final thing we want to do to these cards is to add a caption underneath the image. Add a caption of your own under the image:</p>
<pre><code class="lang-XML">&lt;Label text=&quot;p&#39;tit minou&quot; horizontalAlignment=&quot;center&quot; class=&quot;text&quot;&gt;&lt;/Label&gt;
</code></pre>
<div class="exercise-end"></div>

<blockquote>
    <p><strong>CHALLENGE!</strong>: Can you find a nicer way to layout these cards? Experiment with GridLayouts and AbsoluteLayouts. Show us your results!</p>
</blockquote>

<h3 id="styling-apps-with-css">Styling apps with CSS</h3>
<p>The cards are laid out properly, but they don&#39;t look very good. Time to add some styles!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add some color
</h4>

<p>Choose a pallette of color from <a href="http://coolors.co">Coolors.co</a> or another pallette generator of your choice.</p>
<p>The style sheet in the <code>app</code> folder is automatically associated to your project by its naming convention, so we just have to edit it.</p>
<p>Delete everything in <code>app.css</code>. Add some color to the ActionBar and the Page background by adding a few styles to this file:</p>
<pre><code class="lang-CSS">Page {
    background-color: #EBEBD3;
}

ActionBar {
    background-color: #083D77;
    color: #EBEBD3;
}
</code></pre>
<p>Style the card by adding a css class to the StackLayout in <code>app.component.html</code>:</p>
<pre><code class="lang-XML">&lt;StackLayout width=&quot;40%&quot; *ngFor=&quot;let kitten of kittens&quot; horizontalAlignment=&quot;center&quot; class=&quot;card&quot;&gt;
</code></pre>
<p>Finally, add styles to the card and its label by adding these styles to <code>app.css</code>:</p>
<pre><code class="lang-CSS">.card {
    background-color: #DA4167;
    margin: 10;
    border-radius: 5;
}
.text {
    color: #EBEBD3;
}
</code></pre>
<div class="exercise-end"></div>

<p>Congratulations! With a bit of code, you&#39;ve succesfully created a nice card interface!</p>
<h3 id="creating-robust-animations">Creating robust animations</h3>
<p>The more mobile app development you do, the more you realize that clean animations are not just a &#39;nice-to-have&#39;, they are a &#39;must-have&#39;. Fortunately, NativeScript makes animating components really easy!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Animate a card
</h4>

<p>First, we need to pass through a reference to the card we want to animate, and we do that in the <code>app.component.html</code> XML by giving it an id and adding a function that will fire when we tap the card:</p>
<pre><code class="lang-XML">&lt;StackLayout (tap)=&quot;animate(card)&quot; #card width=&quot;40%&quot; *ngFor=&quot;let kitten of kittens&quot; horizontalAlignment=&quot;center&quot; class=&quot;card&quot;&gt;
</code></pre>
<p>Next, open <code>app.component.ts</code> and import the Animation library at the top:</p>
<pre><code class="lang-TypeScript">import { Animation } from &quot;ui/animation&quot;;
</code></pre>
<p>Then, build out the <code>animate()</code> function. Add this function under the constructor:</p>
<pre><code class="lang-TypeScript">animate(card) {
    card.animate({ opacity: 0 })
        .then(function () { return card.animate({ opacity: 1 }); })
        .then(function () { return card.animate({ translate: { x: 100, y: 100 } }); })
        .then(function () { return card.animate({ translate: { x: 0, y: 0 } }); })
        .then(function () { return card.animate({ scale: { x: 3, y: 3 } }); })
        .then(function () { return card.animate({ scale: { x: 1, y: 1 } }); })
        .then(function () { return card.animate({ rotate: 180 }); })
        .then(function () { return card.animate({ rotate: 0 }); })
        .then(function () {
        console.log(&quot;Animation finished&quot;);
    })
    .catch(function (e) {
        console.log(e.message);
    });
}
</code></pre>
<p>As you can see, we are chaining several animations together using promises. When one completes, the next fires. Test your animation by clicking a card.</p>
<div class="exercise-end"></div>

<blockquote>
    <p><strong>CHALLENGE!</strong>: Create a different animation using the Animation library as documented here: <a href="https://docs.nativescript.org/ui/animation">https://docs.nativescript.org/ui/animation</a></p>
</blockquote>

<p>Now, let&#39;s take a look at the other way of animating elements on the screen—by using CSS keyframe animation. Let&#39;s make the cards fade in during the page loading process. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a keyframe animation
</h4>

<p>To do this, we simply need to tweak the CSS, so open <code>app.css</code> and add a <code>@keyframes</code> rule named <code>card</code>:</p>
<pre><code class="lang-CSS">@keyframes card {
    from { opacity: 0 }
    to { opacity: 1}
}
</code></pre>
<p>Then, add these lines to the <code>.card</code> class:</p>
<pre><code class="lang-CSS">animation-name: card;
animation-duration: 4s;
opacity: 0;
</code></pre>
<p>The app should refresh and the cards will fade in. </p>
<div class="exercise-end"></div>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="beyond-the-basics">Beyond the basics</h2>
<p>You now know how to start NativeScript apps, and how to scaffold out a basic user interface. Now let’s dig deeper. In this workshop you’ll learn how to create Angular services, how to deal with data, and how to setup routing. Let’s start by building an Angular service.</p>
<h3 id="learning-angular-2-data-binding-events-and-services">Learning Angular 2 data binding, events, and services</h3>
<p>In this workshop you’ll be building a simple grocery-management application. Let’s dive right in.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Start up a new app
</h4>

<p>Go ahead and start up a new NativeScript app for this workshop:</p>
<pre><code>tns create WorkshopThree --ng
</code></pre><p>Next, change directories into your new project:</p>
<pre><code>cd WorkshopThree
</code></pre><p>After that, start a livesync watcher with either</p>
<pre><code>tns livesync ios --watch
</code></pre><p>or</p>
<pre><code>tns livesync android --watch
</code></pre><div class="exercise-end"></div>

<p>Open this new project up in Visual Studio Code and let’s start working with Angular services.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Your first service
</h4>

<p>Replace the contents of <code>app.component.ts</code> with the code below, which creates a simple grocery list:</p>
<pre><code class="lang-TypeScript">import { Component, OnInit } from &quot;@angular/core&quot;;
import { GroceryService } from &quot;./grocery.service&quot;;
import { Grocery } from &quot;./grocery&quot;;

@Component({
  selector: &quot;my-app&quot;,
  templateUrl: &quot;app.component.html&quot;,
  providers: [GroceryService]
})
export class AppComponent {
  groceries: Array&lt;Grocery&gt;;

  constructor(private groceryService: GroceryService) {}
  ngOnInit() {
    this.groceries = this.groceryService.get();
  }
}
</code></pre>
<p>And then replace the contents of <code>app.component.html</code> with the code below, which shows the groceries on the screen:</p>
<pre><code class="lang-XML">&lt;GridLayout&gt;
  &lt;ListView [items]=&quot;groceries&quot;&gt;
    &lt;template let-item=&quot;item&quot;&gt;
      &lt;Label [text]=&quot;item.name&quot;&gt;&lt;/Label&gt;
    &lt;/template&gt;
  &lt;/ListView&gt;
&lt;/GridLayout&gt;
</code></pre>
<p>Next, create a file in the <code>app</code> folder named <code>grocery.service.ts</code>, and paste in the following code:</p>
<pre><code class="lang-TypeScript">import { Injectable } from &quot;@angular/core&quot;;
import { Grocery } from &quot;./grocery&quot;;

@Injectable()
export class GroceryService {
  get() {
    let groceries = [];
    groceries.push(new Grocery(&quot;Bananas&quot;));
    groceries.push(new Grocery(&quot;Apples&quot;));
    groceries.push(new Grocery(&quot;Grapes&quot;));
    return groceries;
  }
}
</code></pre>
<p>Finally, create another file in the <code>app</code> folder named <code>grocery.ts</code>, and paste in the following code:</p>
<pre><code class="lang-TypeScript">export class Grocery {
  name: string;
  constructor(name) {
    this.name = name;
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>At this point you should see a hardcoded list of data. Let’s refactor this app so that the data isn’t hardcoded.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Allow users to add groceries
</h4>

<p>Update you <code>app.css</code> with the code below, which will add a bit of spacing to the app you’re building.</p>
<pre><code class="lang-CSS">TextField, Button, Label {
  padding: 15;
}
</code></pre>
<p>Next, change your <code>app.component.html</code> file to use the code below, which sets up a UI that allows users to add data to the list.</p>
<pre><code class="lang-XML">&lt;GridLayout&gt;
  &lt;GridLayout rows=&quot;auto, *&quot;&gt;

    &lt;GridLayout row=&quot;0&quot; columns=&quot;*, auto&quot;&gt;
      &lt;TextField col=&quot;0&quot; hint=&quot;Enter a grocery&quot;&gt;&lt;/TextField&gt;
      &lt;Button col=&quot;1&quot; text=&quot;Add&quot;&gt;&lt;/Button&gt;
    &lt;/GridLayout&gt;

    &lt;ListView row=&quot;1&quot; [items]=&quot;groceries&quot;&gt;
      &lt;template let-item=&quot;item&quot;&gt;
        &lt;Label [text]=&quot;item.name&quot;&gt;&lt;/Label&gt;
      &lt;/template&gt;
    &lt;/ListView&gt;
  &lt;/GridLayout&gt;
&lt;/GridLayout&gt;
</code></pre>
<p>With that setup out of the way, let’s try a quick challenge.</p>
<div class="exercise-end"></div>

<h4 class="exercise-start">
    <b>Challenge</b>: Adding a tap handler
</h4>

<p>NativeScript button elements have a <code>tap</code> event that you can subscribe to using <code>&lt;Button (tap)=&quot;functionName()&quot;&gt;</code>. Angular 2 lets you implement two-way data binding between a text field and a component property using the <code>[(ngModel)]</code> styntax, for instance <code>&lt;TextField [(ngModel)]=&quot;grocery&quot;&gt;</code>.</p>
<p>Your challenge is to combine the two, so that when the user taps the “Add” button they see the value they typed in the text field.</p>
<p>One last note before you get started: replace the contents of your <code>main.ts</code> file with the code below, which adds a <code>NativeScriptFormsModule</code> import you’ll need for this to all work.</p>
<pre><code class="lang-TypeScript">import { platformNativeScriptDynamic, NativeScriptModule } from &quot;nativescript-angular/platform&quot;;
import { NativeScriptFormsModule } from &quot;nativescript-angular/forms&quot;;
import { NgModule } from &quot;@angular/core&quot;;
import { AppComponent } from &quot;./app.component&quot;;

@NgModule({
  declarations: [AppComponent],
  bootstrap: [AppComponent],
  imports: [NativeScriptModule, NativeScriptFormsModule]
})
class AppComponentModule {}

platformNativeScriptDynamic().bootstrapModule(AppComponentModule);
</code></pre>
<div class="solution-start"></div>

<p>Use the following code for your <code>app.component.html</code>:</p>
<pre><code class="lang-XML">&lt;GridLayout&gt;
  &lt;GridLayout rows=&quot;auto, *&quot;&gt;

    &lt;GridLayout row=&quot;0&quot; columns=&quot;*, auto&quot;&gt;
      &lt;TextField col=&quot;0&quot; hint=&quot;Enter a grocery&quot; [(ngModel)]=&quot;grocery&quot;&gt;&lt;/TextField&gt;
      &lt;Button col=&quot;1&quot; text=&quot;Add&quot; (tap)=&quot;add()&quot;&gt;&lt;/Button&gt;
    &lt;/GridLayout&gt;

    &lt;ListView row=&quot;1&quot; [items]=&quot;groceries&quot;&gt;
      &lt;template let-item=&quot;item&quot;&gt;
        &lt;Label [text]=&quot;item.name&quot;&gt;&lt;/Label&gt;
      &lt;/template&gt;
    &lt;/ListView&gt;
  &lt;/GridLayout&gt;
&lt;/GridLayout&gt;
</code></pre>
<p>And the following code for your <code>app.component.ts</code>:</p>
<pre><code class="lang-TypeScript">import { Component, OnInit } from &quot;@angular/core&quot;;
import { GroceryService } from &quot;./grocery.service&quot;;
import { Grocery } from &quot;./grocery&quot;;

@Component({
  selector: &quot;my-app&quot;,
  templateUrl: &quot;app.component.html&quot;,
  providers: [GroceryService]
})
export class AppComponent {
  grocery: String;
  groceries: Array&lt;Grocery&gt;;

  constructor(private groceryService: GroceryService) {}

  ngOnInit() {
    this.groceries = this.groceryService.get();
  }

  add() {
    alert(&quot;You typed &quot; + this.grocery);
  }
}
</code></pre>
<div class="solution-end"></div>

<div class="exercise-end"></div>

<p>Reference:</p>
<ul>
<li><a href="https://angular.io/docs/ts/latest/tutorial/toh-pt4.html">Angular services</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">Angular dependency injection</a></li>
<li><a href="https://docs.nativescript.org/angular/ui/list-view.html">Using NativeScript ListViews</a></li>
</ul>
<h3 id="dealing-with-data">Dealing with data</h3>
<p>In this next section of the workshop you’ll enhance the small grocery list to allow users to add items to the list, and also to persist grocery lists to their devices.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Allow users to add data
</h4>

<p>First, replace the contents of <code>grocery.service.ts</code> with the code below. The changes include removing the hardcoded list, as well as a new <code>add()</code> method.</p>
<pre><code class="lang-TypeScript">import { Injectable } from &quot;@angular/core&quot;;
import { Grocery } from &quot;./grocery&quot;;

@Injectable()
export class GroceryService {
  private groceries: Array&lt;Grocery&gt;;

  constructor() {
    this.groceries = [];
  }

  get() {
    return this.groceries;
  }

  add(name) {
    this.groceries.unshift(new Grocery(name));
  }
}
</code></pre>
<p>Next, replace the contents of <code>app.component.ts</code> with the code below:</p>
<pre><code class="lang-TypeScript">import { Component, OnInit } from &quot;@angular/core&quot;;
import { GroceryService } from &quot;./grocery.service&quot;;
import { Grocery } from &quot;./grocery&quot;;

@Component({
  selector: &quot;my-app&quot;,
  templateUrl: &quot;app.component.html&quot;,
  providers: [GroceryService]
})
export class AppComponent {
  grocery: String;
  groceries: Array&lt;Grocery&gt;;

  constructor(private groceryService: GroceryService) {}

  ngOnInit() {
    this.groceries = this.groceryService.get();
  }

  add() {
    this.groceryService.add(this.grocery);
    this.grocery = &quot;&quot;;
  }
}
</code></pre>
<p>Test your changes by adding a few items to the list.</p>
<div class="exercise-end"></div>

<p>You now have a very basic list, but there’s a big problem: this list isn’t persisted. Let’s look at how to change that.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Persisting data
</h4>

<p>Start by adding the import below to the top of your <code>grocery.service.ts</code> file:</p>
<pre><code class="lang-TypeScript">import { getString, setString } from &quot;application-settings&quot;;
</code></pre>
<p>Next, in the same file, replace the existing <code>add()</code> function with the code below, which saves the grocery list using the application settings module you just imported.</p>
<pre><code class="lang-TypeScript">add(name) {
  this.groceries.unshift(new Grocery(name));
  let names = this.groceries.map((item: Grocery) =&gt; {
    return item.name;
  });
  setString(&quot;groceries&quot;, names.toString());
}
</code></pre>
<p>Your data is now being saved, but it’s up to you to determine how to load this data when the application loads. A challenge!</p>
<div class="exercise-end"></div>

<h4 class="exercise-start">
    <b>Challenge</b>: Loading saved data
</h4>

<p>Your challenge is to change <code>grocery.service.ts</code> to automatically load any data previously stored by the user. As a tip, you’ll want to use the <code>getString()</code> method you imported in the previous exercise.</p>
<blockquote>
<p><strong>NOTE</strong>: A convenient way to restart the app is to add or remove a new line from the TypeScript file you’re currently working on.</p>
</blockquote>
<div class="solution-start"></div>

<p>Replace the constructor in <code>grocery.service.ts</code> with the code below:</p>
<pre><code class="lang-TypeScript">constructor() {
  this.groceries = [];
  let savedGroceriesString = getString(&quot;groceries&quot;); 
  if (savedGroceriesString) {
    savedGroceriesString.split(&quot;,&quot;).forEach((grocery) =&gt; {
      this.groceries.push(new Grocery(grocery));
    });
  }
}
</code></pre>
<div class="solution-end"></div>
<div class="exercise-end"></div>

<p>There are many ways to store data in NativeScript apps. In addition to using the application settings module, you may wish to use one of the options listed below.</p>
<p>Reference:</p>
<ul>
<li><a href="https://github.com/EddyVerbruggen/nativescript-plugin-firebase">NativeScript Firebase plugin</a></li>
<li><a href="https://github.com/couchbaselabs/nativescript-couchbase">NativeScript Couchbase plugin</a></li>
<li><a href="https://github.com/NathanaelA/nativescript-sqlite">NativeScript SQLLite plugin</a></li>
<li><a href="http://docs.nativescript.org/angular/tutorial/ng-chapter-3#34-services">Accessing RESTful HTTP APIs</a></li>
</ul>
<h3 id="setting-up-routing-and-navigation">Setting up routing and navigation</h3>
<p>Routing in a NativeScript app with Angular 2 works very similarly to how it works on the web. In order to get things up and running we have to create a few files.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Set up the routing infrastructure
</h4>

<ul>
<li>Create a new <code>groceries</code> folder in your app.</li>
<li>Move the <code>grocery.ts</code> and <code>grocery.service.ts</code> files into the new <code>groceries</code> folder.</li>
<li>Create new files named <code>groceries.component.html</code> and <code>groceries.component.ts</code> within the <code>groceries</code> folder.</li>
<li>Create a file named <code>app.routing.ts</code> in your root <code>app</code> folder.</li>
</ul>
<p>You should now have a folder structure that looks like this.</p>
<div class="no-copy-button"></div>

<pre><code>app
├── app.component.ts
├── app.css
├── app.routing.ts
├── groceries
│   ├── groceries.component.html
│   ├── groceries.component.ts
│   ├── grocery.service.ts
│   └── grocery.ts
├── main.ts
└── package.json
</code></pre><p>Next, update your <code>groceries.component.ts</code> file to use the code below:</p>
<pre><code class="lang-TypeScript">import { Component, OnInit } from &quot;@angular/core&quot;;
import { RouterExtensions } from &quot;nativescript-angular/router&quot;;

import { GroceryService } from &quot;./grocery.service&quot;;
import { Grocery } from &quot;./grocery&quot;;

@Component({
  selector: &quot;my-app&quot;,
  templateUrl: &quot;groceries/groceries.component.html&quot;,
  providers: [GroceryService]
})
export class GroceriesComponent {
  grocery: String;
  groceries: Array&lt;Grocery&gt;;

  constructor(private groceryService: GroceryService, private routerExtensions: RouterExtensions) {}

  ngOnInit() {
    this.groceries = this.groceryService.get();
  }

  add() {
    this.groceryService.add(this.grocery);
    this.grocery = &quot;&quot;;
  }
}
</code></pre>
<p>After that, copy and paste the contents of <code>app.component.html</code> into <code>groceries.component.html</code>, and delete the <code>app.component.html</code> file.</p>
<p>Finally, update the following three files as follows.</p>
<p><code>app.routing.ts</code>:</p>
<pre><code class="lang-TypeScript">import { Routes } from &quot;@angular/router&quot;;

import { GroceriesComponent } from &quot;./groceries/groceries.component&quot;;

export const appRoutes: Routes = [
  { path: &quot;&quot;, component: GroceriesComponent }
];
</code></pre>
<p><code>app.component.ts</code>:</p>
<pre><code class="lang-TypeScript">import { Component } from &quot;@angular/core&quot;;

@Component({
  selector: &quot;main&quot;,
  template: &quot;&lt;page-router-outlet&gt;&lt;/page-router-outlet&gt;&quot;
})
export class AppComponent { }
</code></pre>
<p><code>main.ts</code>:</p>
<pre><code class="lang-TypeScript">import { platformNativeScriptDynamic, NativeScriptModule } from &quot;nativescript-angular/platform&quot;;
import { NativeScriptFormsModule } from &quot;nativescript-angular/forms&quot;;
import { NativeScriptRouterModule } from &quot;nativescript-angular/router&quot;;
import { NgModule } from &quot;@angular/core&quot;;

import { appRoutes } from &quot;./app.routing&quot;;
import { AppComponent } from &quot;./app.component&quot;;
import { GroceriesComponent } from &quot;./groceries/groceries.component&quot;;

@NgModule({
  declarations: [
    AppComponent,
    GroceriesComponent
  ],
  bootstrap: [AppComponent],
  imports: [
    NativeScriptModule,
    NativeScriptFormsModule,
    NativeScriptRouterModule,
    NativeScriptRouterModule.forRoot(appRoutes)
  ]
})
class AppComponentModule {}

platformNativeScriptDynamic().bootstrapModule(AppComponentModule);
</code></pre>
<div class="exercise-end"></div>

<p>With that your app hasn’t changed, but you’ve moved files around so that you’re setup to add additional routes. Let’s do that!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Scaffold out a new route
</h4>

<p>Create a new <code>about</code> folder within the <code>app</code> folder, and add two files named <code>about.component.html</code> and <code>about.component.ts</code>.</p>
<div class="no-copy-button"></div>

<pre><code>app
├── about
│   ├── about.component.html
│   └── about.component.ts
├── groceries
│   └── ...
└── ...
</code></pre><p>Paste the following code in for <code>about.component.html</code>:</p>
<pre><code class="lang-XML">&lt;ActionBar title=&quot;About&quot;&gt;&lt;/ActionBar&gt;

&lt;StackLayout&gt;
  &lt;Label height=&quot;100&quot; text=&quot;Groceries is a simple grocery management app.&quot; textWrap=&quot;true&quot;&gt;&lt;/Label&gt;
&lt;/StackLayout&gt;
</code></pre>
<p>And the following code to your <code>about.component.ts</code> file:</p>
<pre><code class="lang-TypeScript">import { Component, OnInit } from &quot;@angular/core&quot;;

@Component({
  selector: &quot;my-app&quot;,
  templateUrl: &quot;about/about.component.html&quot;
})
export class AboutComponent {}
</code></pre>
<p>Next, open <code>groceries.component.html</code> back up and add the following code to the very top of the file:</p>
<pre><code class="lang-TypeScript">&lt;ActionBar title=&quot;Groceries&quot;&gt;
  &lt;ActionItem text=&quot;About&quot; (tap)=&quot;navigate()&quot;&gt;&lt;/ActionItem&gt;
&lt;/ActionBar&gt;
</code></pre>
<p>After that, open <code>groceries.component.ts</code> and add the method below to the <code>GroceriesComponent</code> class:</p>
<pre><code class="lang-TypeScript">navigate() {
  this.routerExtensions.navigate([&quot;/about&quot;]);
}
</code></pre>
<p>After that, add <code>AboutComponent</code> to the list of <code>declarations</code> in the <code>NgModule</code> in <code>main.ts</code>. The full file should now look like this:</p>
<pre><code class="lang-TypeScript">import { platformNativeScriptDynamic, NativeScriptModule } from &quot;nativescript-angular/platform&quot;;
import { NativeScriptFormsModule } from &quot;nativescript-angular/forms&quot;;
import { NativeScriptRouterModule } from &quot;nativescript-angular/router&quot;;
import { NgModule } from &quot;@angular/core&quot;;

import { appRoutes } from &quot;./app.routing&quot;;
import { AppComponent } from &quot;./app.component&quot;;
import { GroceriesComponent } from &quot;./groceries/groceries.component&quot;;
import { AboutComponent } from &quot;./about/about.component&quot;;

@NgModule({
  declarations: [
    AppComponent,
    GroceriesComponent,
    AboutComponent
  ],
  bootstrap: [AppComponent],
  imports: [
    NativeScriptModule,
    NativeScriptFormsModule,
    NativeScriptRouterModule,
    NativeScriptRouterModule.forRoot(appRoutes)
  ]
})
class AppComponentModule {}

platformNativeScriptDynamic().bootstrapModule(AppComponentModule);
</code></pre>
<p>And finally, replace the contents of <code>app.routing.ts</code> with the code below, which registers the new about route.</p>
<pre><code class="lang-TypeScript">import { Routes } from &quot;@angular/router&quot;;

import { GroceriesComponent } from &quot;./groceries/groceries.component&quot;;
import { AboutComponent } from &quot;./about/about.component&quot;;

export const appRoutes: Routes = [
  { path: &quot;&quot;, component: GroceriesComponent },
  { path: &quot;about&quot;, component: AboutComponent }
];
</code></pre>
<div class="exercise-end"></div>

<p>At this point you now have two routes, but let’s try tweaking how the routing works with a challenge.</p>
<h4 class="exercise-start">
    <b>Challenge</b>: Configure routing
</h4>

<p>You have two tasks in this challenge: first you must make the navigation from the main component to the about component perform a flip animation, and second you must make the “About” button appear on the right-hand side of the ActionBar on iOS. (If you’re only setup to run Android, work with someone nearby on iOS for this one.)</p>
<p>Here are some documentation pages you can refer to for help:</p>
<ul>
<li><a href="https://docs.nativescript.org/angular/core-concepts/angular-navigation.html#specifying-page-transitions">Specifying page transitions</a></li>
<li><a href="https://docs.nativescript.org/angular/ui/action-bar.html#ios-specifics">iOS specifics of working with NativeScript ActionBars</a></li>
</ul>
<div class="solution-start"></div>

<p>Change the <code>navigate()</code> method in <code>groceries.component.ts</code> to use the code below:</p>
<pre><code class="lang-TypeScript">navigate() {
  this.routerExtensions.navigate([&quot;/about&quot;], {
    transition: {
      name: &quot;flip&quot;
    }
  });
}
</code></pre>
<p>Change the <code>ActionItem</code> in <code>groceries.component.html</code> to have a new <code>ios.position</code> attribute:</p>
<pre><code class="lang-XML">&lt;ActionItem text=&quot;About&quot; (tap)=&quot;navigate()&quot; ios.position=&quot;right&quot;&gt;&lt;/ActionItem&gt;
</code></pre>
<div class="solution-end"></div>

<div class="exercise-end"></div>

<p>With routing out of the way, let’s now look at what is perhaps NativeScript’s coolest feature: the ability to access native iOS and Android APIs.</p>
<h3 id="adding-additional-angular-functionality">Adding additional Angular functionality</h3>
<p>Now that you have a bit of Angular experience let’s try adding a few additional features to this groceries app. This section will be a super special ALL CHALLENGES SECTION—meaning, we’re going to suggest some new functionality for the application, and leave it up to you to do the implementations. No worries though, we’ll provide tips to point you in the right direction, as well as the solutions if you’d like to cheat 😀</p>
<h4 class="exercise-start">
    <b>Challenge</b>: Add delete functionality
</h4>

<p>A grocery list is kind of useless if you can’t delete from the list, and your challenge is to implement a UI that allows users to do that. There are many ways you can choose to implement a UI like this. One potential option is laid out in the Solution below, however, you’re free to take any approach you’d like.</p>
<div class="solution-start"></div>

<p>First, update the <code>&lt;template&gt;</code> in <code>groceries.component.html</code> to use the code below:</p>
<pre><code class="lang-XML">&lt;template let-item=&quot;item&quot;&gt;
  &lt;GridLayout columns=&quot;*, auto&quot;&gt;
    &lt;Label col=&quot;0&quot; [text]=&quot;item.name&quot;&gt;&lt;/Label&gt;
    &lt;Label col=&quot;1&quot; (tap)=&quot;delete(item)&quot; text=&quot;Delete&quot; color=&quot;red&quot;&gt;&lt;/Label&gt;
  &lt;/GridLayout&gt;
&lt;/template&gt;
</code></pre>
<p>Next, add the following function to the <code>GroceriesComponent</code> class in <code>groceries.component.ts</code>:</p>
<pre><code class="lang-TypeScript">delete(grocery: Grocery) {
  this.groceryService.delete(grocery);
}
</code></pre>
<p>Finally, replace the <code>groceries.service.ts</code> file with the code below, which adds a new <code>delete()</code> method, as well as a minor refactor to save changes on additions and deletions.</p>
<pre><code class="lang-TypeScript">import { Injectable } from &quot;@angular/core&quot;;
import { getString, setString } from &quot;application-settings&quot;;

import { Grocery } from &quot;./grocery&quot;;

@Injectable()
export class GroceryService {
  private groceries: Array&lt;Grocery&gt;;

  constructor() {
    this.groceries = [];
    let savedGroceriesString = getString(&quot;groceries&quot;); 
    if (savedGroceriesString) {
      savedGroceriesString.split(&quot;,&quot;).forEach((grocery) =&gt; {
        this.groceries.push(new Grocery(grocery));
      });
    }
  }

  get() {
    return this.groceries;
  }

  add(name) {
    this.groceries.unshift(new Grocery(name));
    this.save();
  }

  delete(grocery: Grocery) {
    let index = -1;
    this.groceries.forEach((item: Grocery, i) =&gt; {
      if (item === grocery) {
        index = i;
      }
    });
    this.groceries.splice(index, 1);
    this.save();
  }

  private save() {
    let names = this.groceries.map((item: Grocery) =&gt; {
      return item.name;
    });
    setString(&quot;groceries&quot;, names.toString());
  }
}
</code></pre>
<div class="solution-end"></div>

<div class="exercise-end"></div>

<p>With the ability to delete groceries implemented, let’s try one additional challenge.</p>
<h4 class="exercise-start">
    <b>Challenge</b>: Add groceries on “Enter” presses
</h4>

<p>Currently you can add groceries by tapping on the “Add” button. But it would be nice if you could also add by pressing the DONE button (or Enter/Return when in a simulator). As a hint, try searching for “return” on the <a href="http://docs.nativescript.org/api-reference/classes/_ui_text_field_.textfield.html">TextField’s API documentation</a>.</p>
<div class="solution-start"></div>

<p>Change the <code>&lt;TextField&gt;</code> in <code>groceries.component.html</code> to use the code below, which adds a new <code>returnKeyType</code> property and <code>returnPress</code> event handler.</p>
<pre><code class="lang-XML">&lt;TextField col=&quot;0&quot; hint=&quot;Enter a grocery&quot; [(ngModel)]=&quot;grocery&quot; returnKeyType=&quot;done&quot; (returnPress)=&quot;add()&quot;&gt;&lt;/TextField&gt;
</code></pre>
<div class="solution-end"></div>

<div class="exercise-end"></div>

<p>And that’s it. It’s time for lunch, and then back to more NativeScript and Angular 2!</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="extensibility-and-plugins">Extensibility and plugins</h2>
<p>In this workshop you will learn how to create your own UI components and also how to create plugins which will use native iOS and Android functionality.</p>
<h3 id="your-first-ui-custom-ui-component">Your first UI Custom UI Component</h3>
<p>Start by creating a new ng project.</p>
<pre><code>tns create WorkshopFive --ng
cd WorkshopFive
</code></pre><p>We will start be creating a <code>hello world</code> type component first, then add it to the <code>app.component</code>.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Set up the first component
</h4>

<p>First create a new file called <code>fun-label.ts</code> in your <code>app</code> folder and add the following code. </p>
<pre><code class="lang-TypeScript">import { Component } from &quot;@angular/core&quot;;

@Component({
    selector: &quot;FunLabel&quot;,
    template: `
    &lt;Label text=&quot;FunLabel&quot;&gt;
    &lt;/Label&gt;
    `
})
export class FunLabel {

}
</code></pre>
<p>This component is a simple <code>@Component</code> that contains NativeScript label saying &quot;FunLabel&quot;.</p>
<p>Now let&#39;s add <code>FunLabel</code> to <code>app.component.html</code>. Add the following line below the label:</p>
<pre><code class="lang-XML">&lt;FunLabel&gt; &lt;/FunLabel&gt;
</code></pre>
<p>But that is not enough to make it work just yet.
The final step is to add the <code>FunLabel</code> declaration to the <code>@NgModule</code> in <code>main.ts</code>
First add this import line to the rest of the imports.</p>
<pre><code class="lang-TypeScript">import { FunLabel } from &quot;./fun-label&quot;;
</code></pre>
<p>and now add <code>FunLabel</code> to declarations</p>
<pre><code class="lang-TypeScript">declarations: [AppComponent, FunLabel],
</code></pre>
<div class="solution-start"></div>

<pre><code class="lang-TypeScript">import { platformNativeScriptDynamic, NativeScriptModule } from &quot;nativescript-angular/platform&quot;;
import { NgModule } from &quot;@angular/core&quot;;
import { AppComponent } from &quot;./app.component&quot;;
import { FunLabel } from &quot;./fun-label&quot;;

@NgModule({
    declarations: [AppComponent, FunLabel],
    bootstrap: [AppComponent],
    imports: [NativeScriptModule],
})
class AppComponentModule {}

platformNativeScriptDynamic().bootstrapModule(AppComponentModule);
</code></pre>
<div class="solution-end"></div>

<p>Now build the app and you should see the nice and shiny <code>FunLabel</code>.</p>
<div class="exercise-end"></div>


<p>The next step is to add binding property to our FunLabel.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Property Binding
</h4>

<p>Open <code>fun-label.ts</code>
We will call the new property <code>line</code> and bind it to the <code>text</code> of the underlying <code>&lt;Label&gt;</code>.</p>
<p>This can be accomplished in three steps.</p>
<p>1) Add Input to the imports</p>
<pre><code class="lang-TypeScript">import { Component, Input } from &quot;@angular/core&quot;;
</code></pre>
<p>2) Change the <code>text=&quot;FunLabel&quot;</code> to</p>
<pre><code class="lang-XML">&lt;Label 
    [text]=&quot;line&quot;&gt;
&lt;/Label&gt;
</code></pre>
<p>3) Add <code>@Input</code> property inside the <code>FunLabel</code> class.</p>
<blockquote>
<p>You can read more about <code>@Input</code>s properties in the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#!#inputs-outputs">Angular docs</a></p>
</blockquote>
<pre><code class="lang-TypeScript">export class FunLabel {
    @Input() public line: string = &quot;&quot;;
}
</code></pre>
<div class="solution-start"></div>

<p>This is how the <code>fun-label.ts</code> should look now.</p>
<pre><code class="lang-TypeScript">import { Component, Input } from &quot;@angular/core&quot;;

@Component({
    selector: &quot;FunLabel&quot;,
    template: `
    &lt;Label 
        [text]=&quot;line&quot;&gt;
    &lt;/Label&gt;
    `
})
export class FunLabel {
    @Input() public line: string = &quot;&quot;;
}
</code></pre>
<div class="solution-end"></div>

<p>To test it out, update the <code>FunLabel</code> in <code>app.component.html</code> to the below code and run the app.</p>
<pre><code class="lang-XML">    &lt;FunLabel 
        [line]=&quot;message&quot;
        class=&quot;message&quot;&gt;
    &lt;/FunLabel&gt;
</code></pre>
<div class="exercise-end"></div>


<p>Now let&#39;s make the FunLabel a bit fun and add some animations.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add animations
</h4>

<p>To perform animations we need to get hold of the <code>Label</code> object first.</p>
<p>We will do it in few steps:</p>
<p>1) Add the required imports for ViewChild, ElementRef and View.</p>
<pre><code class="lang-TypeScript">import { Component, Input, ViewChild, ElementRef } from &quot;@angular/core&quot;;
import { View } from &quot;ui/core/view&quot;;
</code></pre>
<p>2) Add a variable <code>#myLabel</code> definion to the label and call animate on tap</p>
<pre><code class="lang-XML">&lt;Label #myLabel
    [text]=&quot;line&quot;
    (tap)=&quot;animate()&quot;&gt;
&lt;/Label&gt;
</code></pre>
<p>3) Add the label reference to the call</p>
<pre><code class="lang-TypeScript">export class FunLabel {
    @Input() public line: string = &quot;&quot;;
    @ViewChild(&quot;myLabel&quot;) labelRef: ElementRef;
}
</code></pre>
<p>4) Next we can create a getter that will return the NativeScript label object</p>
<pre><code class="lang-TypeScript">export class FunLabel {
    @Input() public line: string = &quot;&quot;;
    @ViewChild(&quot;myLabel&quot;) labelRef: ElementRef;

    private get view() : View {
        return &lt;View&gt;this.labelRef.nativeElement;
    }    
}
</code></pre>
<p>5) Finally we need the function to animate.</p>
<p>Add the following code to the <code>FunLabel</code> class</p>
<pre><code class="lang-TypeScript">private animate() {
    this.zoom();
}

public zoom() {
    this.view.animate({ scale: { x: 0.5, y: 0.5 }  })
        .then(() =&gt; 
            this.view.animate({ scale: { x: 2, y: 2 }  })
        )
        .then(() =&gt; 
            this.view.animate({ scale: { x: 0, y: 0 }  })
        )
        .then(() =&gt; 
            this.view.animate({ scale: { x: 1, y: 1 }, duration: 2000  })
        )
}
</code></pre>
<div class="solution-start"></div>

<p>This is how <code>fun-label.ts</code> should look at this point.</p>
<pre><code class="lang-TypeScript">import { Component, Input, ViewChild, ElementRef } from &quot;@angular/core&quot;;
import { View } from &quot;ui/core/view&quot;;

@Component({
    selector: &quot;FunLabel&quot;,
    template: `
    &lt;Label #myLabel
        [text]=&quot;line&quot;
        (tap)=&quot;animate()&quot;&gt;
    &lt;/Label&gt;
    `
})
export class FunLabel {
    @Input() public line: string = &quot;&quot;;
    @ViewChild(&quot;myLabel&quot;) labelRef: ElementRef;

    private get view() : View {
        return &lt;View&gt;this.labelRef.nativeElement;
    }

    private animate() {
        this.zoom();
    }

    public zoom() {
        this.view.animate({ scale: { x: 0.5, y: 0.5 }  })
            .then(() =&gt; 
                this.view.animate({ scale: { x: 2, y: 2 }  })
            )
            .then(() =&gt; 
                this.view.animate({ scale: { x: 0, y: 0 }  })
            )
            .then(() =&gt; 
                this.view.animate({ scale: { x: 1, y: 1 }, duration: 2000  })
            )
    }
}
</code></pre>
<div class="solution-end"></div>

<div class="exercise-end"></div>

<h4 class="exercise-start">
    <b>Bonus Exercise</b>: Add animationType property
</h4>

<p>Using the below animation functions, add <code>animationType</code> @Input property.
Now the <code>animate</code> function should play one of the below functions.</p>
<pre><code class="lang-TypeScript">public zoom() {
    this.view.animate({ scale: { x: 0.5, y: 0.5 }  })
        .then(() =&gt; 
            this.view.animate({ scale: { x: 2, y: 2 }  })
        )
        .then(() =&gt; 
            this.view.animate({ scale: { x: 0, y: 0 }  })
        )
        .then(() =&gt; 
            this.view.animate({ scale: { x: 1, y: 1 }, duration: 2000  })
        )
}

public spin() {
    this.view.animate({ rotate: 1080, duration: 750 })
        .then(() =&gt; 
            this.view.animate({ rotate: 0, duration: 750 } )
        )
}

public move() {
    this.view.animate({ translate: { x: 100, y: 0 }  })
        .then(() =&gt; 
            this.view.animate({ translate: { x: 100, y: 100 }  })
        )
        .then(() =&gt; 
            this.view.animate({ translate: { x: 0, y: 100 }  })
        )
        .then(() =&gt; 
            this.view.animate({ translate: { x: 0, y: 0 }  })
        )
}
public fade() {
    this.view.animate({ opacity: 0  })
        .then(() =&gt; 
            this.view.animate({ opacity: 1  })
        )
}
</code></pre>
<p>This is how the property should be set in <code>app.component.html</code>:</p>
<pre><code class="lang-XML">&lt;FunLabel 
    [line]=&quot;message&quot;
    class=&quot;message&quot;
    animationType=&quot;fade&quot;&gt;
&lt;/FunLabel&gt;
</code></pre>
<div class="solution-start"></div>

<p>Here is the full solution:</p>
<pre><code class="lang-TypeScript">import { Component, Input, ViewChild, ElementRef } from &quot;@angular/core&quot;;
import { View } from &quot;ui/core/view&quot;;

@Component({
    selector: &quot;FunLabel&quot;,
    template: `
    &lt;Label #myLabel
        [text]=&quot;line&quot;
        (tap)=&quot;animate()&quot;&gt;
    &lt;/Label&gt;
    `
})
export class FunLabel {
    @Input() public line: string = &quot;&quot;;
    @ViewChild(&quot;myLabel&quot;) labelRef: ElementRef;
    @Input() public animationType: string = &quot;fade&quot;;

    private get view() : View {
        return &lt;View&gt;this.labelRef.nativeElement;
    }

    private animate() {
        switch(this.animationType.toLowerCase()) {
            case &quot;spin&quot;:
                this.spin();
                break;
            case &quot;zoom&quot;:
                this.zoom();
                break;
            case &quot;move&quot;:
                this.move();
                break;
            case &quot;fade&quot;:
                this.fade();
                break;
            default:
                this.spin();
        }
    }

    public zoom() {
        this.view.animate({ scale: { x: 0.5, y: 0.5 }  })
            .then(() =&gt; 
                this.view.animate({ scale: { x: 2, y: 2 }  })
            )
            .then(() =&gt; 
                this.view.animate({ scale: { x: 0, y: 0 }  })
            )
            .then(() =&gt; 
                this.view.animate({ scale: { x: 1, y: 1 }, duration: 2000  })
            )
    }

    public spin() {
        this.view.animate({ rotate: 1080, duration: 750 })
            .then(() =&gt; 
                this.view.animate({ rotate: 0, duration: 750 } )
            )
    }

    public move() {
        this.view.animate({ translate: { x: 100, y: 0 }  })
            .then(() =&gt; 
                this.view.animate({ translate: { x: 100, y: 100 }  })
            )
            .then(() =&gt; 
                this.view.animate({ translate: { x: 0, y: 100 }  })
            )
            .then(() =&gt; 
                this.view.animate({ translate: { x: 0, y: 0 }  })
            )
    }
    public fade() {
        this.view.animate({ opacity: 0  })
            .then(() =&gt; 
                this.view.animate({ opacity: 1  })
            )
    }
}
</code></pre>
<div class="solution-end"></div>

<div class="exercise-end"></div>


<p>The final part of creating the <code>FunLabel</code> is to raise an event every time the animation is finished.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Adding event handlers
</h4>

<p>1) Let&#39;s start with the usual of adding new imports <code>Output</code> and <code>EventEmitter</code></p>
<pre><code class="lang-TypeScript">import { Component, Input, ViewChild, ElementRef, Output, EventEmitter } from &quot;@angular/core&quot;;
</code></pre>
<p>2) Now we need to add <code>@Output</code> event property.</p>
<p>When defining an Output property, you can give it a <code>prop-name</code> (this is how it will referenced in the parent component) and <code>return-type</code> (this is the type that is expected to be returned)</p>
<p>@Output public <code>prop-name</code>: EventEmitter&lt;<code>return-type</code>&gt; = new EventEmitter&lt;<code>return-type</code>&gt;();</p>
<p>Add the following <code>@Output</code> property below all the <code>@Input</code> properties—the order is not really important.</p>
<pre><code class="lang-TypeScript">@Output() public animateFinished: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;();
</code></pre>
<p>3) In order to raise the event we just need to call <code>eventname.next(param)</code>.</p>
<p>For this exercise we will add a <code>counter</code> property and return a new value each time an animation is complete.</p>
<p>Then we will wrap it nicely in an <code>emitAnimateFinished()</code> function:</p>
<pre><code class="lang-TypeScript">private counter: number = 0;
private emitAnimateFinished() {
    this.counter++;
    this.animateFinished.next(this.counter);
}
</code></pre>
<p>4) Now the only thing that we have left is to call <code>this.emitAnimateFinished()</code> each time the <code>animation()</code> function is complete.</p>
<p>Here is how to do it for <code>spin()</code></p>
<p>And your task is to do the same for the rest of them (zoom, move and fade).</p>
<pre><code class="lang-TypeScript">public spin() {
    this.view.animate({ rotate: 1080, duration: 750 })
        .then(() =&gt; 
            this.view.animate({ rotate: 0, duration: 750 } )
        )
        .then(() =&gt; 
            this.emitAnimateFinished()
        )
}
</code></pre>
<div class="solution-start"></div>

<p>The <code>FunLabel</code> class should look like this:</p>
<pre><code class="lang-TypeScript">import { Component, Input, ViewChild, ElementRef, Output, EventEmitter } from &quot;@angular/core&quot;;
import { View } from &quot;ui/core/view&quot;;

@Component({
    selector: &quot;FunLabel&quot;,
    template: `
    &lt;Label #myLabel
        [text]=&quot;line&quot;
        (tap)=&quot;animate()&quot;&gt;
    &lt;/Label&gt;
    `
})
export class FunLabel {
    @Input() public line: string = &quot;&quot;;
    @ViewChild(&quot;myLabel&quot;) labelRef: ElementRef;
    @Input() public animationType: string = &quot;fade&quot;;
    @Output() public animateFinished: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;();

    private get view() : View {
        return &lt;View&gt;this.labelRef.nativeElement;
    }

    private counter: number = 0;
    private emitAnimateFinished() {
        this.counter++;
        this.animateFinished.next(this.counter);
    }

    private animate() {
        switch(this.animationType.toLowerCase()) {
            case &quot;spin&quot;:
                this.spin();
                break;
            case &quot;zoom&quot;:
                this.zoom();
                break;
            case &quot;move&quot;:
                this.move();
                break;
            case &quot;fade&quot;:
                this.fade();
                break;
            default:
                this.spin();
        }
    }



    public spin() {
        this.view.animate({ rotate: 1080, duration: 750 })
            .then(() =&gt; 
                this.view.animate({ rotate: 0, duration: 750 } )
            )
            .then(() =&gt; 
                this.emitAnimateFinished()
            )
    }

    public move() {
        this.view.animate({ translate: { x: 100, y: 0 }  })
            .then(() =&gt; 
                this.view.animate({ translate: { x: 100, y: 100 }  })
            )
            .then(() =&gt; 
                this.view.animate({ translate: { x: 0, y: 100 }  })
            )
            .then(() =&gt; 
                this.view.animate({ translate: { x: 0, y: 0 }  })
            )
            .then(() =&gt; 
                this.emitAnimateFinished()
            )
    }

    public zoom() {
        this.view.animate({ scale: { x: 0.5, y: 0.5 }  })
            .then(() =&gt; 
                this.view.animate({ scale: { x: 2, y: 2 }  })
            )
            .then(() =&gt; 
                this.view.animate({ scale: { x: 0, y: 0 }  })
            )
            .then(() =&gt; 
                this.view.animate({ scale: { x: 1, y: 1 }, duration: 2000  })
            )
            .then(() =&gt; 
                this.emitAnimateFinished()
            )
    }
    public fade() {
        this.view.animate({ opacity: 0  })
            .then(() =&gt; 
                this.view.animate({ opacity: 1  })
            )
            .then(() =&gt; 
                this.emitAnimateFinished()
            )
    }
}
</code></pre>
<div class="solution-end"></div>

<p>To put the new event property to test we need to:</p>
<p>a) add an <code>onFinished(val)</code> function to <code>AppComponent</code> in <code>app.component.ts</code></p>
<pre><code class="lang-TypeScript">    public onFinished(val: boolean) {
        alert(&quot;Finished Animation:&quot; + val);
    }
</code></pre>
<p>b) add <code>animateFinished</code> handler to <code>FunLabel</code> in  <code>app.compnent.html</code></p>
<p>Notice the <code>$event</code> attribute passed in as the parameter. This is how you pass the value returned by the component.</p>
<pre><code class="lang-XML">    &lt;FunLabel 
        [line]=&quot;message&quot;
        class=&quot;message&quot;
        animationType=&quot;fade&quot;
        (animateFinished)=&quot;onFinished($event)&quot;&gt;
    &lt;/FunLabel&gt;
</code></pre>
<p>Now run the app. Each time an animation is complete you should get a nice popup with a counter.</p>
<div class="exercise-end"></div>

<p>NativeScript UI components can respond to other events like <code>Double Tap</code>, <code>Long Press</code>, <code>Swipe</code>, <code>Pan</code>, <code>Pinch</code>, <code>Rotation</code>, <code>Touch</code></p>
<h4 class="exercise-start">
    <b>Bonus Exercise</b>: Animate on swipe
</h4>

<p>Read in the documenation how <a href="https://docs.nativescript.org/ui/gestures#swipe">Swipe</a> works and implement different animation for swipe left, right, up and down.</p>
<div class="solution-start"></div>


<p>Here is the full solution. Have fun.</p>
<pre><code class="lang-TypeScript">import { Component, Input, ViewChild, ElementRef, Output, EventEmitter } from &quot;@angular/core&quot;;
import { View } from &quot;ui/core/view&quot;;
import { SwipeGestureEventData } from &quot;ui/gestures&quot;;

@Component({
    selector: &quot;FunLabel&quot;,
    template: `
    &lt;Label #myLabel
        [text]=&quot;line&quot;
        (tap)=&quot;animate()&quot;
        (swipe)=&quot;onSwipe($event)&quot;&gt;
    &lt;/Label&gt;
    `
})
export class FunLabel {
    @Input() public line: string = &quot;&quot;;
    @ViewChild(&quot;myLabel&quot;) labelRef: ElementRef;
    @Input() public animationType: string = &quot;fade&quot;;
    @Output() public animateFinished: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;();

    private get view() : View {
        return &lt;View&gt;this.labelRef.nativeElement;
    }

    private counter: number = 0;
    private emitAnimateFinished() {
        this.counter++;
        this.animateFinished.next(this.counter);
    }

    private animate() {
        switch(this.animationType.toLowerCase()) {
            case &quot;spin&quot;:
                this.spin();
                break;
            case &quot;zoom&quot;:
                this.zoom();
                break;
            case &quot;move&quot;:
                this.move();
                break;
            case &quot;fade&quot;:
                this.fade();
                break;
            default:
                this.spin();
        }
    }



    public spin() {
        this.view.animate({ rotate: 1080, duration: 750 })
            .then(() =&gt; 
                this.view.animate({ rotate: 0, duration: 750 } )
            )
            .then(() =&gt; 
                this.emitAnimateFinished()
            )
    }

    public move() {
        this.view.animate({ translate: { x: 100, y: 0 }  })
            .then(() =&gt; 
                this.view.animate({ translate: { x: 100, y: 100 }  })
            )
            .then(() =&gt; 
                this.view.animate({ translate: { x: 0, y: 100 }  })
            )
            .then(() =&gt; 
                this.view.animate({ translate: { x: 0, y: 0 }  })
            )
            .then(() =&gt; 
                this.emitAnimateFinished()
            )
    }

    public zoom() {
        this.view.animate({ scale: { x: 0.5, y: 0.5 }  })
            .then(() =&gt; 
                this.view.animate({ scale: { x: 2, y: 2 }  })
            )
            .then(() =&gt; 
                this.view.animate({ scale: { x: 0, y: 0 }  })
            )
            .then(() =&gt; 
                this.view.animate({ scale: { x: 1, y: 1 }, duration: 2000  })
            )
            .then(() =&gt; 
                this.emitAnimateFinished()
            )
    }
    public fade() {
        this.view.animate({ opacity: 0  })
            .then(() =&gt; 
                this.view.animate({ opacity: 1  })
            )
            .then(() =&gt; 
                this.emitAnimateFinished()
            )
    }

    private onSwipe(args: SwipeGestureEventData) {
        switch(args.direction) {
            case 1: //Right
                this.view.animate({ translate: { x: 100, y: 0 }, rotate: 90  })
                .then(() =&gt; 
                    this.view.animate({ translate: { x: 0, y: 0 }, rotate: 0  })
                )
                break;
            case 2: //Left
                this.view.animate({ translate: { x: -100, y: 0 }, rotate: -90  })
                .then(() =&gt; 
                    this.view.animate({ translate: { x: 0, y: 0 }, rotate: 0  })
                )
                break;
            case 4: //Up
                this.view.animate({ translate: { x: 0, y: -100 }, scale: { x: 1, y: 3}  })
                .then(() =&gt; 
                    this.view.animate({ translate: { x: 0, y: 0 }, scale: { x: 1, y: 1}   })
                )
                break;
            case 8: //Down
                this.view.animate({ translate: { x: 0, y: 100 }, scale: { x: 1, y: -1}   })
                .then(() =&gt; 
                    this.view.animate({ translate: { x: 0, y: 0 }, scale: { x: 1, y: 1}   })
                )
                break;
        }
    }

}
</code></pre>
<div class="solution-end"></div>

<div class="exercise-end"></div>


<h3 id="using-npm-modules">Using npm modules</h3>
<p>Now that we know how to create our own components, let&#39;s learn how to one created by someone else.
In this exercise you will learn how to add an npm module to the project to get access to additional functionality.</p>
<p>But how do you go about finding one that could work for you?
You can go to:</p>
<ul>
<li><a href="http://plugins.telerik.com/nativescript">NativeScript Plugins page</a>, which contains a set of plugins that have been verified by Telerik. </li>
<li><a href="https://www.npmjs.com/search?q=nativescript"><code>npmjs</code> and search for <code>nativescript</code></a>, which contains a much bigger list of community-written plugins for NativeScript.</li>
</ul>
<p>Let&#39;s learn how to add an npm module.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Installing a NativeScript plugin from npm
</h4>

<p>The usual way to add an npm module would be to call <code>npm i module-name</code>, however when it comes to installing NativeScript-specific plugins it is better to call <code>tns plugin add module-name</code>. That is because <code>tns plugin add</code> will do all that <code>npm install</code> does plus it configures any native dependencies that the plugin may need to use. This might include installing additional native iOS and/or components.</p>
<p>Let&#39;s add the <a href="https://www.npmjs.com/package/nativescript-appinfo">appinfo plugin</a>, which will allow us to get info like the <code>version name</code>, <code>build number</code> and <code>app ID</code>.</p>
<p>Run the following CLI command:</p>
<pre><code>tns plugin add nativescript-appinfo
</code></pre><p>Once you run this command you should be able to see the <code>nativescript-appinfo</code> module inside the <code>node_modules</code> folder and also the dependency to the module should be added to the <code>package.json</code> at the root of the project (not the one in the <code>app</code> folder)</p>
<p>Now let&#39;s try to use the <code>nativescript-appinfo</code> module.</p>
<p>Open <code>app.component.ts</code> and add the following line to the top of the file (or anywhere before <code>@Component</code> starts):</p>
<pre><code class="lang-TypeScript">var appinfo = require(&quot;nativescript-appinfo&quot;);
</code></pre>
<p>This will give us access to the appinfo module in this area of code.</p>
<p>Now we can call the <code>appinfo</code> instance to get some app information. Add the following piece of code inside the <code>onTap()</code> function:</p>
<pre><code class="lang-TypeScript">appinfo.getAppId()
    .then((id) =&gt; {
        alert(&quot;Your app&#39;s id is: &quot; + id);
    });
</code></pre>
<p>Now build the app and see what happens when you tap the button.</p>
<p>As a bonus exercise: run this app in the <code>debug mode</code> and add a break point at <code>getAppId()</code> and try to step in to <code>getAppId()</code> function to see what happens.</p>
<div class="exercise-end"></div>

<p>There are also visual modules that you could use in your app.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Use ColorPicker
</h4>

<p>For this exercise we will use <code>ColorPicker</code>, for more info go to <a href="https://www.npmjs.com/package/nativescript-color-picker">npmjs</a>.</p>
<p>First we need to import it nativescript-color-picker. To do so run the following command in the CLI:</p>
<pre><code>tns plugin add nativescript-color-picker
</code></pre><p>Next open <code>app.components.ts</code> and add a couple of imports. One for the <code>ColorPicker</code> and the other for the <code>Color</code> component.</p>
<pre><code class="lang-TypeScript">import { ColorPicker } from &quot;nativescript-color-picker&quot;;
import { Color } from &quot;color&quot;;
</code></pre>
<p>Then let&#39;s add few bits to the <code>AppComponent</code> class.
We need an instance of the <code>ColorPicker</code> and a <code>selectedColor</code> property.</p>
<pre><code class="lang-TypeScript">private picker = new ColorPicker();
private selectedColor: Color = new Color(&quot;Red&quot;);
</code></pre>
<p>We also need a function that will show the <code>ColorPicker</code> and then passing the result to the <code>selectedColor</code>.</p>
<pre><code class="lang-TypeScript">public showColorPicker() {
    this.picker.show(&#39;#3489db&#39;, &#39;ARGB&#39;)
        .then( (result: number) =&gt; {
            this.selectedColor = new Color(result);
        });
}
</code></pre>
<p>Finally add a Button to <code>app.component.html</code>, which will call <code>showColorPicker()</code> and also with a <code>backgroundColor</code> bound to <code>selectedColor</code>. </p>
<pre><code class="lang-XML">&lt;Button
    text=&quot;ColorPicker Demo&quot;
    (tap)=&quot;showColorPicker()&quot;
    [backgroundColor]=&quot;selectedColor&quot;&gt;
&lt;/Button&gt;
</code></pre>
<p>Now build the app and enjoy the new plugin.</p>
<div class="exercise-end"></div>


<p>The final exercise is to use a UI Component which can be added in html by using its tag.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Use DropDown
</h4>

<p>For this exercise we will use <a href="https://www.npmjs.com/package/nativescript-drop-down">nativescript-drop-down</a>.
Let&#39;s add the plugin by calling </p>
<pre><code>tns plugin add nativescript-drop-down
</code></pre><p>Now in order to make the UI Compoent available in html we need to register it as an element.
This needs to be done in <code>main.ts</code>. We need to import <code>registerElement</code> function and then register the UI component we need.</p>
<p>The first parameter we pass in is the name we want to use for the component, in this case let&#39;s use <code>NSDropDown</code>.
The second parameter we pass is a callback that requires the UI component we want to use.</p>
<pre><code class="lang-TypeScript">import { registerElement } from &quot;nativescript-angular/element-registry&quot;;
registerElement(&quot;NSDropDown&quot;, () =&gt; require(&quot;nativescript-drop-down/drop-down&quot;).DropDown);
</code></pre>
<p>Next let&#39;s add the necessary bits to <code>app.component.ts</code></p>
<pre><code class="lang-TypeScript">public fruits: Array&lt;string&gt; = [
    &quot;apple&quot;, &quot;banana&quot;, &quot;coconut&quot;, &quot;date&quot;, &quot;elderberry&quot;
];

public selectedFruitIndex = 0;
public get selectedFruit() {
    return this.fruits[this.selectedFruitIndex];
}

public itemChanged(selectedIndex){
    this.selectedFruitIndex = selectedIndex;
}
</code></pre>
<p>And now we can use the new component in <code>app.component.html</code>. Notice how we use <code>NSDropDown</code>, as it is defined in <code>main.ts</code>.</p>
<pre><code class="lang-XML">&lt;Label [text]=&quot;selectedFruit&quot;&gt;&lt;/Label&gt;
&lt;NSDropDown #fruitDropDown
    backroundColor=&quot;red&quot;
    [items]=&quot;fruits&quot;
    (selectedIndexChange)=&quot;itemChanged(fruitDropDown.selectedIndex)&quot;&gt;
&lt;/NSDropDown&gt;
</code></pre>
<p>Now build the app and enjoy.</p>
<div class="exercise-end"></div>


<h3 id="managing-platforms-and-node_modules-">Managing <code>platforms</code> and <code>node_modules</code></h3>
<p>When you clone an existing NativeScript app from GitHub, the project will already contain a list of required npm modules (which you can view the <code>package.json</code> file) together with selected platforms (Android and/or iOS) it is designed to work for.</p>
<p>These will get automatically downloaded when you build the project, however until the modules get loaded TypeScript won&#39;t be able to provide you with the support for these modules.</p>
<p>The best thing to do at this stage is to call:</p>
<pre><code>tns install
</code></pre><p>Which will download and configure all the required modules and platforms.</p>
<p><strong>Changing npm module version</strong></p>
<p>When you want to change the version of an npm module, just find it in <code>package.json</code> change the version to the one you need, then delete it from the <code>node_modules</code> folder and finally run <code>tns install</code>.</p>
<p><strong>Trouble shooting new npm installs not working as expected.</strong></p>
<p>Sometimes freshly installed modules with native dependencies don&#39;t seem to work.
This usually happens when you built your app once already. Then you add a new npm module (which requires native Android or iOS support). And you are trying to use the module and run the app again. </p>
<p>The best thing to do is to either delete the <code>platforms</code> folder and rerun the build or you could use the CLI to help you with the task by calling <code>tns platform add</code> and then <code>remove</code>.
Just like this:</p>
<p>For Android:</p>
<pre><code>tns platform remove android
tns platform add android
</code></pre><p>For iOS:</p>
<pre><code>tns platform remove ios
tns platform add ios
</code></pre><h3 id="creating-a-component-with-two-way-binding">Creating a component with two-way binding</h3>
<p>The final task will be to create a custom component with a two-way binding.
How many times do you get tired of creating a Label and a TextField to capture data?
How about we create a component that will contain both a Label and a TextField in one go.</p>
<p>Let&#39;s first scaffold the component.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Scaffold LabelTextField.
</h4>

<p>Create a new file called <code>label-text-field.ts</code> and add the following code. By now this code should be self explanatory.</p>
<pre><code class="lang-TypeScript">import { Component, Input } from &quot;@angular/core&quot;;

@Component({
    selector: &quot;LabelTxt&quot;,
    template: `
    &lt;StackLayout orientation=&quot;horizontal&quot;&gt;
        &lt;Label
            [text]=&quot;label&quot;
            width=&quot;30%&quot;&gt;
        &lt;/Label&gt;
        &lt;TextField #tf
            [text]=&quot;text&quot;
            width=&quot;60%&quot;&gt;&lt;/TextField&gt;
    &lt;/StackLayout&gt;
    `
})
export class LabelTextField {
    @Input() public label: string;
    @Input() public text: string;
}
</code></pre>
<p>Now let&#39;s register the component in <code>main.ts</code>.
First we need to import the new component.
Since <code>LabelTextField</code> is meant to provide two-way binding we also need to import <code>NativeScriptFormsModule</code>.</p>
<pre><code class="lang-TypeScript">import { LabelTextField } from &quot;./label-text-field&quot;;
import { NativeScriptFormsModule } from &quot;nativescript-angular/forms&quot;;
</code></pre>
<p>Next we need to add <code>LabelTextField</code> to declarations and <code>NativeScriptFormsModule</code> to imports.</p>
<p>Replace the current <code>@NgModule</code> with:</p>
<pre><code class="lang-TypeScript">@NgModule({
    declarations: [AppComponent, FunLabel, LabelTextField],
    bootstrap: [AppComponent],
    imports: [NativeScriptModule, NativeScriptFormsModule],
})
</code></pre>
<p>Finally let&#39;s add the few <code>LabelTextFields</code> to the UI.
Add a couple of properties to the <code>AppComponent</code> class in <code>app.component.ts</code>: </p>
<pre><code class="lang-TypeScript">public name: string = &quot;annonymous&quot;;
public telephone: string =&quot;0123456789&quot;;
</code></pre>
<p>Open <code>app.components.html</code> and add the following code.
Note that our compenent uses <code>LabelTxt</code> tag.</p>
<pre><code class="lang-XML">&lt;LabelTxt
    label=&quot;Name&quot;
    [text]=&quot;name&quot;&gt;
&lt;/LabelTxt&gt;
&lt;LabelTxt
    label=&quot;Telephone&quot;
    [text]=&quot;telephone&quot;&gt;
&lt;/LabelTxt&gt;

&lt;FunLabel
    [line]=&quot;name&quot;&gt;
&lt;/FunLabel&gt;
&lt;FunLabel
    [line]=&quot;telephone&quot;&gt;
&lt;/FunLabel&gt;
</code></pre>
<p>Build the app and you should be able to see a bunch of Labels with TextFields next to them, together with the FunLabels, which display the same value. However if you edit any of the TextFields the FunLabels won&#39;t get updated.</p>
<div class="exercise-end"></div>

<p>Now let&#39;s add two way binding on <code>TextField.text</code> property to <code>LabelTextField</code>.
Add the end of this exercise you will be able to use <code>LabelTextField</code> with <code>[(ngModel)]</code>.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Implement ControlValueAccessor
</h4>

<p>Open <code>label-text-field.ts</code>.</p>
<p>Let&#39;s start with adding the necessary imports.</p>
<pre><code class="lang-TypeScript">import { Component, Input, Inject, Optional } from &#39;@angular/core&#39;;
import { NgControl, ControlValueAccessor } from &#39;@angular/forms&#39;;
</code></pre>
<p>Next we need to extend <code>LabelTextField</code> class so that it implements <code>ControlValueAccessor</code>.</p>
<pre><code class="lang-TypeScript">export class LabelTextField implements ControlValueAccessor {
</code></pre>
<blockquote>
<p>At this point Visual Studio Code will complain that <code>writeValue</code> (it is called when the bound property is changed outside of this component), <code>registerOnChange</code> (it is called at the beginning to provide an onChange function) and <code>registerOnTouched</code> (it is called at the beginning to provide onTouched function) functions are missing. Also in order to use <code>LabelTextField</code> with <code>[(ngModel)]</code> we need to set up a value accessor in the constructor.</p>
</blockquote>
<p>Update <code>LabelTextField</code> class to:</p>
<pre><code class="lang-TypeScript">export class LabelTextField implements ControlValueAccessor {
    private _changeFn: any;

    @Input() public label: string;
    @Input() public text: string;

    constructor(@Inject(NgControl) @Optional() ngc: NgControl) {
        if (ngc) {
            ngc.valueAccessor = this;
        }
    }

    // Write a new value to the element.
    writeValue(obj: any): void {
        this.text = obj;
    }

    // Set the function to be called when the control receives a change event.
    registerOnChange(fn: any): void {
        this._changeFn = fn;
    }

    // Set the function to be called when the control receives a touch event.
    registerOnTouched(fn: any): void {
    }
}
</code></pre>
<p>At this point you should be able to update <code>LabelText</code> components in html to use <code>[(ngModel)]</code> instead of <code>[text]</code>, but still editing the <code>TextField</code> won&#39;t update the bound properties.
That is because we need to add change detection to the TextField -&gt; Text.</p>
<p>We will do it in two steps.</p>
<p>1) Add the following function to <code>LabelTextField</code> class, which will call <code>_changeFn</code> (ngModel&#39;s onChanged function provided through <code>registerOnChange</code> ).</p>
<pre><code class="lang-TypeScript">updateTextProperty(newText) {
    if (this._changeFn) {
        if (this.text + &quot;&quot; !== newText + &quot;&quot;) {
            this._changeFn(newText);
        }
    }
}
</code></pre>
<p>2) Add <code>textChange</code> handler to TextField in the <code>template</code>, so that every time the user types something in the <code>TextField</code> this will call <code>updateTextProperty</code> and ultimately update <code>ngModel</code>.</p>
<pre><code class="lang-XML">&lt;TextField #tf
    [text]=&quot;text&quot;
    (textChange)=&quot;updateTextProperty(tf.text)&quot;
    width=&quot;60%&quot;&gt;
&lt;/TextField&gt;
</code></pre>
<p>Now let&#39;s just update <code>LabelTxt</code> in <code>app.component.html</code> to use <code>ngModel</code></p>
<pre><code class="lang-XML">&lt;LabelTxt
    label=&quot;Name&quot;
    [(ngModel)]=&quot;name&quot;&gt;
&lt;/LabelTxt&gt;
&lt;LabelTxt
    label=&quot;Telephone&quot;
    [(ngModel]=&quot;telephone&quot;&gt;
&lt;/LabelTxt&gt;
</code></pre>
<p>Build the app and enjoy.</p>
<div class="exercise-end"></div>


<h4 class="exercise-start">
    <b>Bonus Exercise</b>: Derive TextField hint from label text property
</h4>

<p>TextField has a <code>hint</code> property, which provides a hint to the user as to what they could type. Which you can you like this:</p>
<pre><code class="lang-XML">&lt;TextField #tf
    [text]=&quot;text&quot;
    (textChange)=&quot;updateTextProperty(tf.text)&quot;
    [hint]=&quot;label&quot;
    width=&quot;60%&quot;&gt;
&lt;/TextField&gt;
</code></pre>
<p>Can you update <code>LabelTextField</code> so that it automatically takes value of <code>label</code> puts it to lower case and appends ... ?
For example if the <code>label</code> value is &quot;Email&quot; then the <code>hint</code> value should be <code>email...</code>.</p>
<div class="solution-start"></div>

<p>In order to solve this puzzle we need a property getter, which will return the transformed label value</p>
<pre><code class="lang-TypeScript">public get simpleHint() {
    return this.label.toLowerCase() + &quot;...&quot;;
}
</code></pre>
<p>And then bind <code>hint</code> of the <code>TextField</code> to <code>simplehint</code></p>
<pre><code class="lang-xml">&lt;TextField #tf
    [text]=&quot;text&quot;
    (textChange)=&quot;updateTextProperty(tf.text)&quot;
    [hint]=&quot;simplehint&quot;
    width=&quot;60%&quot;&gt;
&lt;/TextField&gt;
</code></pre>
<div class="solution-end"></div>


<div class="exercise-end"></div>
			</div>
			<hr>
			<div class="chapter">
				<h2 id="code-sharing">Code sharing</h2>
<h3 id="the-case-for-code-sharing">The case for code sharing</h3>
<p>If you have a use case that requires sharing code between a web site and a mobile app, have I got the tool for you! Introducing Nathan Walker&#39;s <a href="Advanced Angular2 Seed">https://github.com/NathanWalker/angular2-seed-advanced</a> project. This project is based on Minko Geshev&#39;s <a href="Angular 2 Seed">https://github.com/mgechev/angular2-seed</a> project which allows you to quickly spin up a web site, but it takes this project vastly forward with the introduction of allowing code to be shared between web, desktop via Electron, and mobile via NativeScript. You can quickly spin up three apps in one fell swoop.</p>
<p>The Advanced Seed project also integrates i18n support for multilingual apps by leveraging ngTranslate, as well as analytics via Angulartics and a test harness so you can test your code...and more!</p>
<p>This technological advancement is brought to you by the advent of Angular 2, which decoupled the DOM so that we can start sharing large parts of our codebase for various platforms.</p>
<p>In this workshop, we&#39;re going to work with the <a href="PokeAPI">http://pokeapi.co/</a> to populate a list on the web as well as iOS and Android.</p>
<h3 id="getting-started-with-the-advanced-angular2-seed-repo">Getting started with the Advanced-Angular2-Seed repo</h3>
<p>Let&#39;s get up and running with the Advanced Seed. Please refer to the <a href="Readme">https://github.com/NathanWalker/angular2-seed-advanced</a> to ensure that your environment is ready.</p>
<pre><code>&gt; git clone --depth 1 https://github.com/NathanWalker/angular2-seed-advanced.git
&gt; cd angular2-seed-advanced
&gt; npm install
&gt; npm start
</code></pre><p>Start the mobile workflow</p>
<pre><code>iOS:                      npm run start.ios
iOS (livesync emulator):  npm run start.livesync.ios
iOS (livesync device):    npm run start.livesync.ios.device

// or...using AVD or Genymotion Android emulator

Android:                      npm run start.android
Android (livesync emulator):  npm run start.livesync.android
Android (livesync device):    npm run start.livesync.android.device
</code></pre><p>You should have a web site and either an iOS or Android simulator running. You can also run two simulators at once if you like. </p>
<blockquote>
<p>Note, on occasion your mobile livesyncing may fail when using this seed. On occasion, you may need to restart the process, so press Ctrl&gt;C in your terminal and restart the <code>npm run start.livesync...</code> routine.</p>
</blockquote>
<h3 id="exploring-the-architecture">Exploring the architecture</h3>
<p>Open the root folder of your app in your IDE of choice. Let&#39;s take a look at all the moving parts. Navigate to the <code>src</code> folder.</p>
<p><code>app/frameworks</code>: contains your shared application architecture code. </p>
<ul>
<li><code>core</code>: foundation layer (decorators and low-level services)</li>
<li><code>analytics</code>: analytics provided by <a href="https://segment.com/">Segment</a></li>
<li><code>i18n</code>: internationalization features</li>
<li><code>electron</code>: <a href="http://electron.atom.io/">Electron</a> specific code</li>
<li><code>test</code>: test specific code providing conveniences to make testing your code easier and faster</li>
</ul>
<p>The code we will be editing in this workshop is:</p>
<ul>
<li><code>sample</code>: contains shared navigational components like navbar and toolbar and <code>sample.module.ts</code> which is the app&#39;s &#39;switchboard&#39;</li>
<li><code>sample/services</code>: contains services that can communicate with a backend</li>
<li><code>app/components</code>: contains pages (home and about) and base app code</li>
</ul>
<p>The NativeScript app is found in the <code>nativescript</code> folder. Make any mobile-specific edits in this folder, such as adding icons and splash screen images to your <code>app/App_Resources</code> folder.</p>
<ul>
<li>To edit both web and mobile apps, you can make changes to files in <code>src/client</code> or <code>nativescript</code> folders. </li>
<li>A symbolic link exists between the web <code>src/client</code> and the <code>nativescript</code> folder so changes in either location are mirrored because they are the same directory inside.</li>
</ul>
<blockquote>
<p>Note: Normally when greenfielding a project using this seed, it&#39;s best for maintenance ease to create a fresh folder for your new app code in <code>src/client/app/frameworks</code> - for example the PocketRave app is located in <code>src/client/app/frameworks/pocketrave</code> - and then change any paths that point to the <code>app</code> folder. This way, you can upgrade your project by checking out a new copy of the Advanced Seed and then dropping your app&#39;s folder into <code>/frameworks</code>. For this workshop, however, we will simply be editing files in <code>src/client/app/components</code>. Reference <a href="http://www.github.com/jlooper/pocketrave">PocketRave</a> as an example of this type of setup. Visit <a href="PocketRave">http://PocketRave.me</a> online for a full demo of this app.</p>
</blockquote>
<h3 id="making-a-cross-platform-edit">Making a cross-platform edit</h3>
<p>Let&#39;s change this app from being a shout-out to great scientists to being a celebration of Pokemon! Because we can!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Edit the app&#39;s structure
</h4>

<p>Let&#39;s remove the language switcher component, which is a dropdown on the web and a segmented bar on mobile. Let&#39;s also edit the app&#39;s title.</p>
<p>First, let&#39;s make some edits on the web. Navigate in VSCode to <code>src/client/app/frameworks/sample/components/</code>. In this folder are stored the navigation type files (toolbar and navbar) for this app. </p>
<p>Open <code>toolbar.component.html</code>. The language-switcher is included here as <code>&lt;lang-switcher&gt;&lt;/lang-switcher&gt;</code>. Delete that line.</p>
<p>Change the <code>&lt;h1&gt;&lt;/h1&gt;</code> tag in this file for the web as well to &quot;I love Pokemon!&quot;.</p>
<p>Your web app should refresh and you will see the site without the language switcher.</p>
<p>Second, let&#39;s make these same edits on mobile.</p>
<p>Now take a look at <code>src/client/app/frameworks/sample/components/toolbar.component.tns.html</code> - note it has intentionally been left blank. </p>
<p>Normally this type of file would have corresponding code to match web and mobile layouts. Note the naming conventions of these files. Anything with <code>.tns.</code> is destined to be used in a <code>Telerik NativeScript</code> app. For our case, however, we need to navigate to <code>src/client/app/components/app.component.tns.html</code> to remove the <lang-switcher></lang-switcher> component. Edit the ActionBar as well with the new title.</p>
<p>In this file, change the title of the app in the <code>&lt;ActionBar&gt;</code> markup to be &quot;I love Pokemon!&quot;.</p>
<p>Note how the app title is contained in an <code>&lt;h1&gt;</code> on web and an <code>&lt;ActionBar&gt;</code> on mobile. This illustrates the limited ability, currently, of the app to share every bit of code between web and mobile, as the layouting mechanism is very different on these two platforms. We will see tighter codesharing in a minute, however.</p>
<p>By removing the language switcher, we&#39;ve broken the i18n translations, so let&#39;s delete everything in the body of the home page and rebuild it. Go to <code>src/client/app/components/home</code> and delete everything in <code>home.component.tns.html</code> and <code>home.component.html</code>.</p>
<div class="exercise-end"></div>

<p>The takeaway from this exercise is that you have full control over where your code goes, but there are some patterns that start to manifest themselves. Most importantly, note the naming conventions that allow you to separate your code per platform.</p>
<h3 id="adding-a-service">Adding a service</h3>
<p>Let&#39;s add a service to consume data brought in from the PokeAPI. We&#39;re going to display a list of pokemon on all platforms. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a service
</h4>

<p>Add a new file to <code>src/client/app/frameworks/sample/services/</code> called <code>pokemon.service.ts</code> and paste in the following:</p>
<pre><code>import {Injectable} from &#39;@angular/core&#39;;
import {Http, Response} from &#39;@angular/http&#39;;
import {LogService} from &#39;../../core/services/log.service&#39;;
import {Observable} from &#39;rxjs/Rx&#39;;
import &#39;rxjs/add/operator/map&#39;;

@Injectable()
export class PokemonService {
    private requestURL: string;

    constructor(
        private logger: LogService,
        private http: Http) {
        logger.debug(`pokemon service initializing...`);
        this.requestURL = &#39;http://pokeapi.co/api/v2/pokemon&#39;;
    }

    public getPokemon(): Observable&lt;any&gt; {
        let pokemonURL = this.requestURL;
        return this.http.get(pokemonURL)
            .map((res) =&gt; {
                let pokemon = res.json();
                return pokemon.results || [];
            })
            .catch(this.handleError);
    }


    private handleError(error: Response) {
        return Observable.throw(error);
    }
}
</code></pre><p>Now, let&#39;s integrate this service into the app:</p>
<p>Navigate to <code>src/client/app/frameowrks/sample/sample.module.ts</code> to include service like this:</p>
<p>Paste this line under the multilingualReducer line:</p>
<pre><code>import { PokemonService } from &#39;./services/pokemon.service&#39;;
</code></pre><p>and ensure that it&#39;s listed as a provider by adding it to the list of providers under <code>NameListService</code>:</p>
<pre><code>providers: [
    NameListService,
    PokemonService
  ],
</code></pre><p>Add this service into the index.ts list of available services by adding this export to the bottom of <code>src/client/app/frameworks/sample/index.ts</code>:</p>
<pre><code>export * from &#39;./services/pokemon.service&#39;;
</code></pre><p>Finally, you need to import this service into your frontend files, so that your home pages can leverage it. Navigate to <code>src/client/app/components/home/home.component.ts</code> and replace the content of this file with this:</p>
<pre><code>// libs
import {BehaviorSubject} from &#39;rxjs/BehaviorSubject&#39;;
import {OnInit} from &#39;@angular/core&#39;;

// app
import { BaseComponent } from &#39;../../frameworks/core/index&#39;;
import { PokemonService } from &#39;../../frameworks/sample/index&#39;;

@BaseComponent({
  moduleId: module.id,
  selector: &#39;sd-home&#39;,
  templateUrl: &#39;home.component.html&#39;,
  styleUrls: [&#39;home.component.css&#39;]
})
export class HomeComponent implements OnInit { 

  public pokemon$: BehaviorSubject&lt;Array&lt;any&gt;&gt; = new BehaviorSubject([]);

  constructor(
    public pokemonService: PokemonService
    ) {}

  ngOnInit() {
    this.pokemonService.getPokemon()
      .subscribe((pokemon: Array&lt;any&gt;) =&gt; {
          this.pokemon$.next(pokemon);
      });
  }
}
</code></pre><div class="exercise-end"></div>

<p>You now have a service that returns an array via an http call to the PokeAPI. Notice, you only have one service and it&#39;s sent to the frontend in one call. Now, you can display the data as you like, using web and mobile layouts!</p>
<h3 id="rebuilding-the-home-screen">Rebuilding the home screen</h3>
<p>We are going to show a list of Pokemon, as returned by the service, on both web and mobile screens. On mobile, we will simply display a ListView, and on the web, we will show a simple set of <code>&lt;p&gt;</code> tags. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Edit the frontend
</h4>

<p>Delete everything in <code>src/client/app/components/home/home.component.tns.html</code> and paste in the following code to add a ListView for the mobile app:</p>
<pre><code>&lt;StackLayout class=&quot;container-content&quot;&gt;
    &lt;GridLayout columns=&quot;*&quot; rows=&quot;*&quot;&gt;
        &lt;ListView [items]=&quot;pokemon$ | async&quot; row=&quot;1&quot; height=&quot;300&quot;&gt;
            &lt;template let-item=&quot;item&quot;&gt;
                &lt;StackLayout&gt;
                    &lt;Label [text]=&quot;item.name&quot;&gt;&lt;/Label&gt;
                &lt;/StackLayout&gt;
            &lt;/template&gt;
        &lt;/ListView&gt;
    &lt;/GridLayout&gt;
&lt;/StackLayout&gt;
</code></pre><p>Then, replace the code in <code>src/client/app/components/home/home.component.html</code> with the code below to create a simple list on native:</p>
<pre><code>&lt;ul *ngFor=&quot;let pokemon of pokemon$ | async&quot;&gt;
    &lt;li&gt;{{ pokemon.name }}&lt;/li&gt;
&lt;/ul&gt;
</code></pre><div class="exercise-end"></div>

<p>With just a few lines of code, you&#39;ve built a cross-platform presentation screen to show a list of Pokemon! </p>
<blockquote>
    <p><strong>SUPER CHALLENGE!</strong>:  Make this app into a master-detail screen. You will need to use the url that this API passes to you, pass it through a (tap) function on the front end, and switch the screen to display the detail of the Pokemon, which will require another API call. Good luck! Take a look at <a href="https://github.com/jlooper/practice-buddy-mobile-app-2.0">PracticeBuddy</a> for tips.</p>
</blockquote>

<h3 id="customize-the-css-by-platform">Customize the CSS by platform</h3>
<p>You can truly fine-tune the look of your web and native mobile app by isolating certain elements of the CSS associated to each file, simply by paying attention to the the names of the files. </p>
<p>In the <code>src/client/app/components/home</code> folder, note the naming convention of the css files. CSS for the web for the home page, for example, is handled by <code>home.component.css</code> and CSS for mobile is handled by <code>home.component.tns.css</code>. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Tweak the CSS
</h4>

<p>The listview looks a little crunched on mobile, so edit the  <code>src/client/app/components/home/home.comonent.tns.css</code>:</p>
<pre><code>.list-item {
  padding: 10;
  margin: 10;
}
</code></pre><div class="exercise-end"></div>

<blockquote>
    <p><strong>CHALLENGE!</strong>:  Do some more CSS tweaks to personalize your apps. Try to make both global and local css changes and see how it looks.</p>
</blockquote>


<h3 id="using-opaquetokens">Using OpaqueTokens</h3>
<p>It&#39;s easy enough to create shared services and forked frontend code with this Seed, but soon enough you will need to integrate a plugin that can only be used on mobile. This integration must be shielded from the web, as it will break the web frontend if not done properly. Enter the wonderful world of <a href="http://blog.thoughtram.io/angular/2016/05/23/opaque-tokens-in-angular-2.html">OpaqueTokens</a>!</p>
<p>If, for example, you wanted to use a special Audio plugin in your NativeScript app, but didn&#39;t want that plugin to be exposed to the web view, you would inject a string token representing that plugin at runtime. For the token to be available during the dependency injection process you setup providers for the token. </p>
<p>Let&#39;s use a Loader plugin that will only be available for the mobile app.  </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Setup a plugin and a token
</h4>

<p>First, install the plugin in your NativeScript app: </p>
<pre><code>&gt; cd nativescript
&gt; tns plugin add nativescript-loading-indicator
</code></pre><blockquote>
<p>Note, you may need to rebuild the app to make the plugin install properly (<code>npm run start.ios/android</code>)</p>
</blockquote>
<p>Now set up the token system. First, take a look at the &#39;switchboard&#39; of your app: <code>src/app/frameworks/sample/sample.module.ts</code>. This is the main ngModule of your app and it needs to include a master file of tokens that we are going to call token.ts. 
In <code>sample.module.ts</code>, make the following edits:</p>
<p>At the top, under the block of imports for &#39;app&#39;, add this line:</p>
<pre><code>import { TOKENS_SHARED } from &#39;../core/tokens&#39;;
</code></pre><p>Then, edit the Providers array:</p>
<pre><code>providers: [
    NameListService,
    PokemonService,
    TOKENS_SHARED
  ],
</code></pre><p>Now, create a file in <code>src/app/frameworks/core</code> called tokens.ts and paste the following code in this file:</p>
<pre><code>import {OpaqueToken} from &#39;@angular/core&#39;;

export const LOADER: OpaqueToken = new OpaqueToken(&#39;LoadingIndicator&#39;);

export const TOKENS_SHARED: Array&lt;any&gt; = [
  { provide: LOADER, useValue: {} }
];
</code></pre><p>Then, edit <code>nativescript/app/native.module.ts</code> in a similar way to add a reference to tokens only available to the mobile app:</p>
<p>At the bottom of the &#39;app&#39; block of imports, import a native token file reference:</p>
<pre><code>import { TOKENS_NATIVE } from &#39;./tokens.native&#39;;
</code></pre><p>Edit the import block at the bottom as well:</p>
<pre><code>CoreModule.forRoot([
      TOKENS_NATIVE,
      { provide: WindowService, useClass: WindowNative },
      { provide: ConsoleService, useValue: console }
    ]),
</code></pre><p>Now create a file in this folder called <code>tokens.native.ts</code>.</p>
<pre><code>import {LOADER} from &#39;./app/frameworks/core/tokens&#39;;
import { LoadingIndicator } from &#39;nativescript-loading-indicator&#39;;

export const TOKENS_NATIVE: Array&lt;any&gt; = [
  { provide: LOADER, useClass: LoadingIndicator}
];
</code></pre><p>Similarly, edit the web module: <code>src/client/web.module.ts</code>, adding a reference to web tokens at the top, in the &#39;app&#39; block of imports:</p>
<pre><code>import { TOKENS_WEB } from &#39;./tokens.web&#39;;
</code></pre><p>Complete the integration by adding the tokens as a provider:</p>
<pre><code>CoreModule.forRoot([
      TOKENS_WEB,
      { provide: WindowService, useValue: window },
      { provide: ConsoleService, useValue: console }
    ]),
</code></pre><p>Add a file called <code>src/client/tokens.web.ts</code> with a blank array (you could populate this later with other types of tokens)</p>
<pre><code>export const TOKENS_WEB: Array&lt;any&gt; = [
  //empty for now
];
</code></pre><p>Now you can reference the native tokens you built in your mobile code. Replace the current code in <code>src/client/app/component/home/home.component.ts</code> with the following:</p>
<pre><code>// libs
import {BehaviorSubject} from &#39;rxjs/BehaviorSubject&#39;;
import {OnInit, Inject} from &#39;@angular/core&#39;;
import {LOADER} from &#39;../../frameworks/core/tokens&#39;;
import {Config} from &#39;../../frameworks/core/utils/config&#39;;

// app
import { BaseComponent } from &#39;../../frameworks/core/index&#39;;
import { PokemonService } from &#39;../../frameworks/sample/index&#39;;

@BaseComponent({
  moduleId: module.id,
  selector: &#39;sd-home&#39;,
  templateUrl: &#39;home.component.html&#39;,
  styleUrls: [&#39;home.component.css&#39;]
})
export class HomeComponent implements OnInit { 

  public pokemon$: BehaviorSubject&lt;Array&lt;any&gt;&gt; = new BehaviorSubject([]);

  constructor(
    public pokemonService: PokemonService,
    @Inject(LOADER) private LoadingIndicator: any
    ) {}

  ngOnInit() {
    if (Config.IS_MOBILE_NATIVE()) {
      this.LoadingIndicator.show();
    }
    this.pokemonService.getPokemon()
      .subscribe((pokemon: Array&lt;any&gt;) =&gt; {
          this.pokemon$.next(pokemon);
          if (Config.IS_MOBILE_NATIVE()) {
            this.LoadingIndicator.hide();
          }
      });
  }
}
</code></pre><p>Now you are able to view the loading indicator on mobile only; it is shielded from the web view. </p>
<div class="exercise-end"></div>

<blockquote>
    <p><strong>CHALLENGE!</strong>:  Play with tokens - add a new web-only token, or a new mobile only token. Several tokens are integrated into <a href="http://www.github.com/jlooper/pocketrave">PocketRave</a>.</p>
</blockquote>


<h3 id="bonus-running-a-test">Bonus: Running a test</h3>
<p>As a brief demo, we&#39;re going to look at how unit tests can be integrated into this app. There is already built-in functionality to test; we simply need to edit what we&#39;re testing so the tests will pass. All we&#39;re actually testing for is that our <code>&lt;h1&gt;</code> contains the words &#39;I love Pokemon!&#39;</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Write a test
</h4>

<p>Unit tests are associated to each folder; there are a few in the <code>src/cient/app/components/home</code> folder, so navigate there and paste the following into the <code>home.component.spec.ts</code> file:</p>
<pre><code>import {TestComponentBuilder, TestBed} from &#39;@angular/core/testing&#39;;
import {Component} from &#39;@angular/core&#39;;
import {FormsModule} from &#39;@angular/forms&#39;;
import {RouterModule} from &#39;@angular/router&#39;;

// libs
import {provideStore} from &#39;@ngrx/store&#39;;
import {TranslateModule} from &#39;ng2-translate/ng2-translate&#39;;

import {t} from &#39;../../frameworks/test/index&#39;;
import {TEST_CORE_PROVIDERS, TEST_HTTP_PROVIDERS, TEST_ROUTER_PROVIDERS} from &#39;../../frameworks/core/testing/index&#39;;
import {NameListService, nameListReducer, PokemonService} from &#39;../../frameworks/sample/index&#39;;
import {TEST_MULTILINGUAL_PROVIDERS} from &#39;../../frameworks/i18n/testing/index&#39;;
import {HomeComponent} from &#39;./home.component&#39;;

// test module configuration for each test
const testModuleConfig = () =&gt; {
  TestBed.configureTestingModule({
    imports: [FormsModule, RouterModule, TranslateModule.forRoot()]
  });
};

export function main() {
  t.describe(&#39;@Component: HomeComponent&#39;, () =&gt; {

    t.be(testModuleConfig);

    t.it(&#39;should work&#39;,
      t.async(t.inject([TestComponentBuilder], (tcb: TestComponentBuilder) =&gt; {
        tcb.createAsync(TestComponent)
          .then((rootTC: any) =&gt; {

            rootTC.detectChanges();

          });
      })));
  });
}

@Component({
  providers: [
    TEST_CORE_PROVIDERS(),
    TEST_HTTP_PROVIDERS(),
    TEST_ROUTER_PROVIDERS(),
    provideStore({ names: nameListReducer }),
    NameListService,
    PokemonService,
    TEST_MULTILINGUAL_PROVIDERS()
  ],
  selector: &#39;test-cmp&#39;,
  directives: [HomeComponent],
  template: &#39;&lt;sd-home&gt;&lt;/sd-home&gt;&#39;
})
class TestComponent {

}
</code></pre><p>then, in the same folder, paste this code into <code>home.component.e2e-spec.ts</code>:</p>
<pre><code>import {t} from &#39;../../frameworks/test/index&#39;;

declare var browser: any, element: any, by: any;

t.describe(&#39;Home&#39;, function () {

  t.be(function () {
    browser.get(&#39;/&#39;);
  });

  t.it(&#39;should have correct h1&#39;, function () {
    t.e(element(by.css(&#39;sd-app sd-home h1&#39;)).getText()).toEqual(&#39;I love Pokemon!&#39;);
  });


});
</code></pre><p>You should now be able to run a test to check whether the <code>&lt;h1&gt;</code> tag is correct by typing <code>npm test</code> into a terminal at the root of your project.</p>
<blockquote>
<p>Note: Delete the files <code>app.component.spec.ts</code> and <code>app.component.e2e-spec.ts</code> to get these tests to pass </p>
</blockquote>
<div class="exercise-end"></div>

<blockquote>
    <p><strong>CHALLENGE!</strong>:  Test something else!</p>
</blockquote>

<p>Congratulations! You have built a service, customized a web and mobile app at the same time, tweaked its UI, and tested it! Just think of all the amazing web sites and apps you&#39;ll be able to spin up in the near future.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="super-ultimate-challenge">SUPER ULTIMATE CHALLENGE</h2>
<p>It’s the end of the day, therefore you’re more ready than ever for the SUPER MEGA ULTIMATE CHALLENGE. That’s right, get ready to test your NativeScript skills against the biggest and baddest data form that we can reaslistically tackle in an hour. Get pumped.</p>
<h3 id="what-s-the-challenge-">What’s the challenge?</h3>
<p>Your challenge, should you choose to accept it, is to build a form that collects four pieces of information from the user: a name, an email address, a date of birth, and whether they’d like to sign up for a newsletter. You’re welcome to design this form however you’d like, and you totally might want to use the <a href="https://docs.nativescript.org/ui/theme">new NativeScript theme</a>, but here’s one lackluster UI you can try to replicate:</p>
<p><img src="images/ios-form.png" style="height: 450px; border: 0;">
<img src="images/android-form.png" style="height: 450px; border: 0;"></p>
<p>The form should send a POST request to the following endpoint:</p>
<pre><code>https://api.everlive.com/v1/GWfRtXi1Lwt4jcqK/Accounts
</code></pre><p>The body of the request should be a JSON stringified object that has the following four keys: <code>Name</code>, <code>Email</code>, <code>DOB</code>, and <code>Newsletter</code>. (Don’t worry about the specific formatting of the individual paramters; aka, send an date format you’d like for <code>DOB</code>, and any boolean format you’d like for <code>Newsletter</code>.)</p>
<p>There’s a simple listing of all data that has come through hosted at <a href="https://jsfiddle.net/dLvz083w/">https://jsfiddle.net/dLvz083w/</a>. If you see your data on this list you’ve completed the challenge successfully.</p>
<p>And if you finish, there are some super special <a href="#chapter7.3">bonus challenges</a> for you to tackle.</p>
<h3 id="starting-up-the-challenge">Starting up the challenge</h3>
<h4 class="exercise-start">
    <b>Exercise</b>: Start up a new app
</h4>

<p>Every good challenge starts with a new app. For this challenge go ahead and start a new blank project with the <code>tns create</code> command.</p>
<pre><code>tns create CHALLENGE --ng
</code></pre><p>Next, change directories into your new project:</p>
<pre><code>cd CHALLENGE
</code></pre><p>After that, open your <code>main.ts</code> file and replace its contents with the code below, as you’ll be needing both the <code>NativeScriptFormsModule</code> and <code>NativeScriptHttpModule</code> to complete this challenge.</p>
<pre><code class="lang-TypeScript">import { platformNativeScriptDynamic, NativeScriptModule } from &quot;nativescript-angular/platform&quot;;
import { NativeScriptFormsModule } from &quot;nativescript-angular/forms&quot;;
import { NativeScriptHttpModule } from &quot;nativescript-angular/http&quot;;
import { NgModule } from &quot;@angular/core&quot;;
import { AppComponent } from &quot;./app.component&quot;;

@NgModule({
  declarations: [AppComponent],
  bootstrap: [AppComponent],
  imports: [
    NativeScriptModule,
    NativeScriptFormsModule,
    NativeScriptHttpModule
  ]
})
class AppComponentModule {}

platformNativeScriptDynamic().bootstrapModule(AppComponentModule);
</code></pre>
<p>Finally, create a <code>account.service.ts</code> file in your <code>app</code> folder and paste in the following code. You’ll need this service to hit this challenge’s backend that we’ll discuss momentarily. You’ll have to figure out how to use this service like you did in <a href="#chapter4.0">chapter 4.0</a>. </p>
<pre><code class="lang-TypeScript">import { Injectable } from &quot;@angular/core&quot;;
import { Http, Headers } from &quot;@angular/http&quot;;
import { Observable } from &quot;rxjs/Rx&quot;;
import &quot;rxjs/add/operator/catch&quot;;
import &quot;rxjs/add/operator/map&quot;;
import { Account } from &quot;./account&quot;;

@Injectable()
export class AccountService {
  constructor(private http: Http) {}

  add(account: Account) {
    let headers = new Headers();
    headers.append(&quot;Content-Type&quot;, &quot;application/json&quot;);

    return this.http.post(
      &quot;https://api.everlive.com/v1/GWfRtXi1Lwt4jcqK/Accounts&quot;,
      JSON.stringify({
        &quot;Name&quot;: account.name,
        &quot;Email&quot;: account.email,
        &quot;DOB&quot;: account.dob,
        &quot;Newsletter&quot;: account.newsletter
      }),
      { headers: headers }
    )
    .catch((error) =&gt; {
      console.log(error);
      return Observable.throw(error);
    })
  }
}
</code></pre>
<div class="exercise-end"></div>

<p>And with that, you’re ready to get started.</p>
<h3 id="tips-to-help-you-out">Tips to help you out</h3>
<p>Below you’ll find a few tips if you find yourself getting stuck, and a few suggestions for how you improve this little app if you have some extra time. Towards the end of the hour we’ll share a full solution that you can refer to later.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: TIPS
</h4>

<p>Stuck? Here are a few tips that might help you get this form up and running.</p>
<div class="solution-start"></div>

<ul>
<li><strong>Tip #1</strong>: You can use <code>[(ngModel)]</code> to bind to <code>&lt;TextField&gt;</code>, <code>&lt;DatePicker&gt;</code>, and <code>&lt;Switch&gt;</code> UI components. You’re going to want to use something like this:</li>
</ul>
<pre><code class="lang-XML">&lt;TextField [(ngModel)]=&quot;account.name&quot;&gt;&lt;/TextField&gt;
&lt;DatePicker [(ngModel)]=&quot;account.dob&quot;&gt;&lt;/DatePicker&gt;
&lt;Switch [(ngModel)]=&quot;account.newsletter&quot;&gt;&lt;/Switch&gt;
</code></pre>
<ul>
<li><strong>Tip #2</strong>: You can create a divider in your UI with the following bit of XML and CSS.</li>
</ul>
<pre><code class="lang-XML">&lt;StackLayout class=&quot;divider&quot;&gt;&lt;/StackLayout&gt;
</code></pre>
<pre><code class="lang-CSS">.divider {
  height: 1;
  background-color: black;
  margin-top: 20;
  margin-bottom: 20;
}
</code></pre>
<div class="solution-end"></div>

<div class="exercise-end"></div>

<h3 id="bonus-challenges-">Bonus challenges!</h3>
<p>Finish the challenge? Most excellent. But wait, there’s more! Here are some ways you can improve this form. See how many of these things you can finish in an hour.</p>
<ul>
<li>While saving the form disable all form fields so the user cannot interact with them. Hint: You can bind to the <code>isEnabled</code> property that all form fields have.</li>
<li>Show an activity indicator while the form is submitting. There’s a handy <a href="https://docs.nativescript.org/angular/code-samples/activity-indicator.html">ActivityIndicator UI component</a> that’ll work nicely for this.</li>
<li>Show an alert after the form successfully submits, and also when something goes wrong. Refer to the <a href="https://docs.nativescript.org/angular/ui/dialogs.html">dialogs module</a> for more information.</li>
<li>Don’t allow the user to submit with an empty name or email. Show an alert, or even find a more custom way to display an error message on your form.</li>
</ul>
<p>And that’s it. When you’re done make sure to show us how far you made it 😀</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="where-to-go-from-here-">Where to go from here?</h2>
<p>Congratulations! You’ve completed the NativeScript workshop 🎉</p>
<p>Regardless of what you choose to do with NativeScript, joining the NativeScript community is a great way to keep up with the latest and greatest in the NativeScript world. Here are some ways you can get involved:</p>
<ul>
<li><strong>Join the <a href="http://developer.telerik.com/wp-login.php?action=slack-invitation">NativeScript Community Slack</a></strong>. The community Slack is a great place to ask questions, and chat with others in the NativeScript community.</li>
<li><strong>Follow <a href="https://twitter.com/nativescript">@nativescript</a> on Twitter</strong> for updates on all things NativeScript.</li>
<li><strong>Sign up for the <a href="https://www.nativescript.org/nativescript-newsletter">NativeScript newsletter</a></strong>. The newsletter will deliver NativeScript articles, news, plugin updates, and more straight to your inbox.</li>
</ul>

			</div>
		</div>
	</div>
</div>

<script src="scripts/built.js"></script>

</body>
</html>
